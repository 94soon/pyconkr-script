이제 3시가 돼서 두 번째 세션을 시작하도록 하겠습니다.

이번에 말씀드리려는 것은 Django Channels을 가지고 서버를 구축하고 여러 클라이언트가 같은 작 업을 관찰하고 이런 것을 만들었던 이야기와 그걸 Django Channels 1.대 버전에서 2.대로 옮겨가면 서 어떤 문제가 있었는지 그리고 이 이야기는 이제 Django Channels에 대한 이야기이기도 하지만 신규 패키지 업그레이드를 할 때 생길 수 있는 일이기도 해서 그런 것에 대한 교훈 이런 것에 대해서 이야기를 할 예정입니다.

제목은 버전업 삽질기인데 두 번째 제목은 얼리어답터의 길은 멀고도 험하다입니다.

본격 발표로 들어가기 전에 잠깐 제 소개를 드리면 저는 n년차 회사 다니는 개발자고요.

어쩌다 보면 번역도 해서 기술서 번역 2개 나와 있고 하나 예정이고, 이메일은 다음과 같습니다.

그래서 다시 한번 발표 개요를 말씀드리면요.

먼저 제가 만들려는 게 무슨 앱인가, 그리고 Channels을 가지고 뭘 할 수 있는가.

Channels 1.x에서는 어떤 구성을 가지고 있고 구현이 되었는가.

그리고 실제로 만들어본 데모가 있고요.

2.x에서는 다시 왜 1.x로 만들어놓고 마이그레이션을 했는가.

그리고 다시 2.x에서 바뀐 개념, 구현한 것, 바꾼 것, 그 리고 2.x 데모를 보여드리겠습니다.

참고로 1.x와 2.x는 당연하겠지만 거의 같습니다.

마이그레이션이 니까요.

이걸 통해서 무엇을 얻었는가 하는 점과 어떤 걸 보면 지금 발표에서 나온 이야기나 기타 그 이상의 정보를 얻을 수 있는가를 소개를 드릴 예정입니다.

제가 이걸 시작한 게 올해 1월, 리서치 기간까지 합치면 작년 12월인데요.

회사에 새로 들어갔더니 운영하는 도구를 만들어야 한다고 하더라고요.

그런데 이거는 사용자는 웹 버튼만 누르고 그 결과를 버튼을 누른 사용자 말고도 여러 사람이 볼 수 있어야 하는 그런 문제가 있었습니다.

그래서 이게 왜 필요한가 하면 서버의 스크립트 결과 같은 게 계속 길게 나오고 있는데요.

배포를 20 대 정도에 하면 줄줄이 여기서 뭐하고 있다, 여기서 뭐하고 있다.

그런데 아무것도 사용자에게 돌려 주지 않으면 불안하잖아요.

그래서 웹에서 관찰할 수 있게 하는 게 목적이었습니다.

그리고 이걸 하다 보니까 웹 소켓이라는 게 있다더라.

이걸 쓰면 좋겠다.

자바 스크립트 쪽에서 열심 히 폴링을 하는 건데 이걸 끝냈니, 안 끝냈니 하면서 하고 싶지 않았어요.

그리고 기왕 Django로 만들기 시작했으니까 가능하면 별로 특별한 일을 하지 않아도 통합을 할 수 있으면 좋겠다고 생각해서 생각한 것이 Django Channels이었습니다.

Channels 프로젝트에 보면 Channels은 여러 프로토콜을 좀 더 쉽게 확장하기 위한 거고요.

Django에 서 http 말고도 프로토콜로 확장을 하는 것이 되겠습니다.

그리고 당연하지만 Django에 메인 프로젝트이기 때문에 Django가 기본적으로 통합이 잘 됩니다.

생 각할 필요가 없어요.

이를테면 인스톨 채널 하면 그냥 따라오고 앱에 Channels 넣어주면 끝납니다.

그러면 참 잘 만났네요 하고 이걸 쓰기로 했죠.

Django view로 제공하고요.

웹소켓으로 오고 가게 되고, 프로세스 모니터링을 하니까 표준 출력하고 표준 에러를 구분하기도 했어요.

일단 이런 식으로 접근을 하기로 하고, Channels 1.x를 쓰기 시작했죠.

그래서 채널에서 아마 익숙하지 않은 분들도 계실 것 같아서 Channels 자체도 소개를 드리겠고요.

1.x에서는 이 프로젝트 이름이 Channels이잖아요.

채널이라는 개념이 따로 설명도 되어 있고 좀 중요 해요.

이를테면 채널 레이어라는 게 있어서 그 채널이 메시지 관리를 해 주는 거예요.

채널 레이어를 구성하고 있는 것은 메시지 큐 소프트웨어 등을 설정해서 쓸 수 있고요.

그 채널 레이 어 안에 여러 개의 레이어가 존재하게 됩니다.

사용자가 저희 사이트에 접속을 해요.

그러면 http 리퀘스트라는 채널에 사용자가 짠하고 들어오게 되는 거예요.

그러면 이 사용자는 또 응답 채널이라는 것으로 표현이 되고요.

사용자 하나마다 어떤 임의의 문자, 밑에 http.res~ 문자가 있잖아요.

임의로 만들었고, 메시지 큐가 각각 여러 개 별도의 메시지 큐 이렇 게 되어 있고요.

그리고 Channels 1.x에서는 일단 인터페이스 서버가 들어오는 커미션을 다 받아요.

그래서 포켓 연결 은 전부 다 인터페이스 서버가 다 알아서 해 주는 거고, 워커가 워커 프로세스가 따로 떠 있거든요.

그래서 메시지를 읽고 다시 컨슈머 코드를 워커가 실행을 해 줍니다.

그러니까 소켓 연결에 대한 프로세스는 모르고요.

메시지 하나하나마다 그때그때 워커가 가져가서 하다 보니까 연결과 관련된 것은 다 따로 따로 받거나 해야 되는 게 있습니다.

메시지 단위의 처리가 Channels 1.x의 특징입니다.

그래서 컨수머라는 게 메시지를 컨수머한다고 해서 하고요.

스트림 구성을 위해서 멀티플렉서와 리멀티플렉서를 지원하고 있습니다.는 연결은 하나인데 여러 개 의 논리적 스트림을 구성할 수 있고, 컨수머 앞단에 넣어서 메시지가 전달이 되게 됩니다.

그룹이나 객체가 있고요.

이 그룹은 여러 개의 응답 채널들의 모임이에요.

그런데 1.x에서는 그룹에 메시지를 보내면 그 메시지와 실제 관계되어 있는 컨수머와 관계가 없이 직접 사용자 소켓까지 메시 지가 쭉 가게 되어있어요.

이런 얘기가 왜 필요한가 하시겠지만 이게 다 나중에 뒤집히거든요.

그게 좀 문제였습니다.

그래서 애플리케이션 구현인데요.

컨수머를 채널 라이브러리에서 지원을 해 주고 있어요.

필요한 것은 이미 들어와 있는 것에 대해서 메시지를 해석해서 제가 하고 싶은 일을 하는 것, 그쪽 비 즈니스 로직이 들어가는 거고.

실제로 로직이 돌아가고 있는 상황에서 보낸 메시지는 또 따로 둬서 이쪽을 통해서 명령을 요청하지 않은 상태에서도 메시지를 보내는 부분이 있고요.

그래서 그냥 계속해서 메시지를 누군가 보내고 있고, 이 브로드캐스팅 그룹에 들어온 애들은 다 일단 들어온 다음에는 모두 같은 메시지를 받게 될 거예요.

그리고 앞에서도 잠시 말씀을 드렸지만 워커를 별도로 구동을 해 줘야 되고요.

실제로 인터페이스 서 버 이름이 다프네인데 다프네를 먼저 띄워주고 채널 레이어는는 뭐라고 알려준 다음에 워커를 띄우 면 채널 레이어, 제가 사용한 걸 통해서 메시지를 가져갈 수 있게 됩니다.

잠시 1.x 데모를 보여드리겠습니다.

데모는 굉장히 간단해서, 일단은 코멘트를 보낼고요.

여기서 코멘트 스타트를 보내면 저쪽에서 어떤 메시지를 보낼 거예요.

이렇게 하면 메시지가 오는데요.

일단은 리시브를 받은 것은 스타트를 받아서, 제가 만든 거는 그냐 이 데모를 위해서 가장 간단히 만 든 버전인데 메시지를 받으면 데이터베이스에 넣고 그 아이디를 돌려준 다음에 그 아이디에 있는 상 태가 메시지를 계속 보내라는 상태인 동안은 끊임없이 메시지를 보내는 거예요.

그래서 여기 보시면 일단 코맨드에 스타트가 들어오면 이 그룹에 채널을 넣어주고 이쪽으로 따로 할 수 있다고 알려주고, 그러면 계속해서 그룹 센드를 통해서 메시지가 나가게 됩니다.

보시면 여기는 논리적으로 있고요.

이게 논리적 스텝이라는 걸 보시려면 46번...

지금 보시면 스크린 에러라고 나오고 있고 페이로드가 있잖아요.

클라이언트가 별로 친절하지 않아서 이렇게 나오는데, 그런데 이쪽에서 받을 때는 이미 해석된 것만 받기 때문에 이쪽은 디멀티플렉스한 게 돼요.

이제 커맨드 쪽에 그만하라고 알려주면 더 이상 보내지 않습니다.

멈췄어요.

대충 지금 멀티플렉스를 구현을 해서 넣은 방식이고요.

Channels 1.x의 튜토리얼을 보신 분들은 다른 방법이 있다는 것도 아실 텐데 1.x까지는 클래스가 아 니라 개별 http 리퀘스크라든가 따로 연결을 해 줄 수 있었어요.

1.x까지만 됩니다.

논리적 스크린이 실제로 어떻게 돌아가는지랑 구현이 의도한 대로 잘 되었다는 걸 보셨고요.

그러면 왜 잘 되는데 굳이 2.x로 갔는가.

사실 다 핑계고요.

새로 나왔다길래 써보고 싶었습니다.

그리고 이유를 더 붙이자면 인증을 안한 상태였어요.

사실 아직도 안 했습니다.

이게 회사 일이었는 데 일단 인증 필요없으니까 그냥 나가자고 해서.

아무튼 인증이나 세션을 언젠가 넣어야 되니까 그렇 다면 2.x에 가면 쉬어질 것 같다.

그래서 그러면 2.x로 가기에 저한테는 충분한 이유가 됐죠.

그리고 이 애플리케이션은 어차피 점점 복잡해 질 텐데 2.x는 처음부터 소개에 1.x를 그냥 싹 바꾸면 안 돌아간다고 코드 고칠 거 많을 거라고 했거든요.

그러면 어차피 언젠가 할 것 같으면 고칠 코드가 적을 때 하는 게 좋지 않나 그런 생각을 했고요.

그렇게 제가 작년 12월에 시작한 프로젝트를 3월에 Channels 2.x를 가지고 다시 만들게 되었습니다.

그러면 2.x가 뭐가 많이 바뀌었는가 말씀을 드려야 되는데요.

설명 페이지에 보시면 터틀즈 올더 웨이 다운이라는 말이 나와요.

이게 아마 지구가 어떻게 그냥 이렇게 잘 있을 수 있는가, 사람 사는 세상이.

그거에 대한 영감인데요.

거북이가 받치도 있어서, 그러면 그 거북이 밑에는 뭐가 있지? 다른 거북이, 내내 거북이들이 우리 사 는 세상을 받치고 있는 거북이가 계속 있는 거죠.

그런데 이거는 거북이는 아니고요.

asgi 스펙을 구현하는 그런 클래스를 층층이 쌓아요.

그래서 우리가 구현할 최소 단위의 컨수머도 그냥 asgi 스펙을 만족하는 거고, 다른 중간에 미들 웨어 도 그 스펙에 따라서 움직이는 거고, 그런 식으로 되어 있고요.

그리고 2.x로 오면서 달라진 점이 1.x에서는 소켓 연결은 전부다 인터페이스 서버가 관리를 했어요.

그런데 2.x에 오면서 메시지 단위로 워커는 알아서 움직이고 연결은 인터페이스 서버가 해 주는 게 아니라 컨수머 하나하나도 다 연결이 되게 했어요.

그러니까 커넥션별로 생성이 됐다가 그 커넥션이 끝나면 같이 컨수머 인스턴스도 없어지고 그런 식 이 됩니다.

그래서 이름은 컨수머인데 지금은 메시지 컨숨이라는 의미는 아니게 됐죠.

url 루트 같은 정보가 필요하잖아요.

예전 같으면 오기가 어려운데 2.x가 되면서 셀프 스콥이라는 데 에 그 정보가 다 들어갔어요.

이쪽은 asgi 개념이 있고요.

Cunsumer가 연결 동안 유지되는 것에 대해서 상태를 가질 수 있다고 보시면 됩니다.

그리고 제가 멀티플렉스를 쓰고 있었는데 이미 고치기 시작했는데 봤더니 구현이 안 됐더라고요.

멀티플렉스도 없어, 디 멀티플렉스도 없어 그런 상황이고, 그것도 어떤 직접 메시지를 보내는 객체라 기보다는 중간자예요.

어떤 그룹에는 어떤 Consumer들이 들어있다, 그렇게 정보를 관리를 하고 그룹으로 보내면 다시 그 Cunsumer한테 보내버려요, 알아서 보내라고.

이게 이제 2.x에서 1.x와 크게 바뀐 부분들입니다.

그래서 일단 다시 시작을 했으니까 없는 건 없는 것대로 살아야 되잖아요.

다시 엎을 게 아니면 이미 다 주변에 얘기를 해 놔서 돌아갈 길도 없고 그래서 구현이 안 되어 있으면 논리적으로 하지 말고 논 리적으로 하면 되잖아, 이게 되었죠.

그래서 논리적 스트림을 별도의 url로 분리해서 구현하기로 했는데, 이게 그냥 이렇게 되어 있습니다.

지금은 중간에 스트림 이름을 하나 끼워넣었고.

그리고 그룹으로 보내는 메시지를 처리하는 구는 현한 container에 하나 끼워넣어야 돼요.

그룹 이름에 보내는 메시지를 넣었는데 여기에서 타입으로 어떤 문자열을 넣으면 그걸 받을 Cunsumer가 릴레이를 가지고 있어야 되는 거죠.

그러면 릴레이가 받는 것은 그냥 메시지에 통째로 줘요.

그러면 알아서 이 타입을 빼든 중간에 넣은 콘텐츠만 다시 꺼내든 해서 보내면 되고요.

최종 사용자한테는 이를 콘텐츠 안에 구현된 내용만 가게 했습니다.

눈에 띄는 거라면 데몬은 Async로 구현했습니다.

그래서 프로젝트는 아직이에요.

그리고 이제 만들었으면 투입을 해야 되잖아요.

그런데 2.x에 오니까 따로 띄우는 게 아니라 인터페이스 서버라는 게 없는 건 아닌데요.

이게 역할도 바뀌고 띄우는 방식도 달라졌어요.

그래서 워커 프로세스는 필요한 만큼 알아서 만들라고 하고요.

실제로는 python 매니지 파일해서 넌서버를 우르면 실제 서버가 뜨는 것은 다프네 쪽에 서버 클래스 가 만들어져서 뜨게 됩니다.

하지만 워커 프로세스가 뜨는 건 아니니까 워커는 필요한 만큼 열심히 잘 띄워주면 되고, 그래서 전 에 버전에서는 별로 프로세스가 죽든 말든 신경을 안 썼다가 버전을 올리면서 프로세스의 수퍼바이 저를 도입을 했어요.

여기에서도 신 버전의 위험성이 느껴지는 게 많이 쓰는 게 수퍼바이저라고 해서 찾아봤더니 python 3.6은 지원하지 않습니다.

그래서 써커스라는 걸 도입하게 됐고요.

써커스가 토내도 패키지에 의존을 하고 있는데, 그냥 의존하 는 거는 알아서 끌어와서 깔게 만들면 동작을 안 합니다.

그래서 버전도 맞춰주고.

그리고 써커스를 도입한 다른 큰 이유라면 그냥 설치를 할 수 있어서였고요.

2.x를 좀 더 길게 설명할 수 있을 줄 알았는데 벌써 데모의 차례가 왔네요.

사실 데모의 버전이 걱정돼서 스크린 리코딩도 해 왔는데 다행히 별 문제 없이 돌아가고 있습니다.

그렇죠, 이런 문제 하나쯤 터져줘야...

잠시만 기다려주세요.

다행히 이 문제가 뭔지 알고 있어서요.



채널 레이어를 쓰려면 이렇게 지정을 해 주면 되는데, 제가 1.x에서도 썼거든요.

진짜 다행인게 2.x로 로 오면서 레디스밖에 지원을 안 해요.

그래서 갈아엎는 일은 생기지 않았습니다.

당연하지만 똑같은 역할을 하는 데모고요.

달라진 점이라면 url 생긴 게 이렇게 달라진 중간에 이렇게 88번에 하겠다고 하면 그냥 이것만 옵니 다.

노멀에 대한 것만 오니까 애초에 스트림 같은 것도 필요없고요.

별도의 채널로 연결을 하면 두 가지를 볼 수 있게 된다는.

그래서 물리적으로 커넥션이 2배가 되었지만 하는 역할은 똑같습니다.

그게 의도한 게 맞고요.

심심하니까 조금 더...

코드를 보시면 여기서는 url 루트에 아이디를 보내거든요.

이런 식으로 하면 맨 끝에 이 아이디가 이런 식으로 해석이 돼서 옵니다.

그러면 셀프 스콥이니까 당연히 여기 구현한 거에서도 액세스할 수 있고요.

그룹에 추가를 시켜주고 그러면 그룹에 메시지를 보내주는 애가 이런 식으로 그룹 센드를 해서 릴레 이로 다시 보내면 이를 릴레이가 실제로는 컨텐트를 보내줍니다.

이게 1.x랑 이 부분이 많이 다른 점이죠.

메시지를 멈춰줬고요.

그래서 지금까지 Channels 1.x, 2.x 아키텍처나 구현하는 방식에 대해서 설명을 드렸고요.

이런 기술적인 것 외에라면 얼리어답터가 되려면 문서를 정말 꼼꼼하게 읽어야 된다.

모든 페이지를 처음부터 끝까지 다 보고 시작하는 게 좋겠다는 교훈을 얻었고, 그다음에 또 다른 것 은 그래도 문서가 완벽하기는 좀 어려워요.

그래서 아쉬운 사람이 코드를 잘 까볼 각오를 하자.

잘하면 이제 남들도 많이 필요하겠다 싶으면 다시 문서에 복원을 하는 방식도 있겠죠.

충분히 부지런 하시다면.

그리고 의존성 있는 라이브러리끼리는 버전을 잘 맞춰줘야 한다.

안 그러면 도저히 이해하지 못할 오 류 메시지를 만나게 됩니다.

이를테면 채널을 쓸 때는 채널 자체랑 채널 레디스라는 프로 자체랑 asgi 패키지랑 인터페이스 서버 얘들이 모두 다 버전이 맞아야 제대로 돌아갑니다.

이해가 안 돼서 한참 고민하다가 그냥 버전을 바꿨더니 되는 그런 일들이 있고요.

들어주셔서 감사합니다.



