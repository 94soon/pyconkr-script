https://www.youtube.com/watch?v=QdrtUt7qPL8

예, 이 시간에, 저도 좀 오기 싫었거든요. 

와주셔서 감사합니다. 

그러면 이번 세션 시작하도록 하겠습니다.

제 소개를 드리자면요. 

저는 게임개발자입니다. 

서버가 파이썬으로 되어 있기 때문에 많은 관심 부탁드리고요.

그리고 재작년부터 제가 파이썬을 시작했기 때문에 여러분보다 파이썬 경력은 짧을 것 같습니다. 

경력이 짧더라도 이번 세션 귀엽게 들어주시면 감사하겠습니다.

네, 제가 만든 결과부터 소개하겠습니다.

이건 switch문이고요. 

정수 문자에 다른 값도 넣을 수 있기 때문에요. 

패턴매칭 흉내도 낼 수 있는 문장구조입니다.

그리고 switch문은 에스이프 문대신 쓸 수 있습니다.

주의사항부터 말씀드리고 시작하겠습니다.

제가 만든 switch문에 대한 필요성은 이번 세션에 다루지는 않습니다.

이번 세션의 목적은 파이썬 문법을 확장하는 방법에 대한 발표입니다.

또 파이썬 인터프리터가 C언어로 되어 있는 관계로 C언어가 많이 나옵니다. 

그리고 저는 오늘 컴파일러 교수님 모드가 될 것 같습니다.

전문용어가 많이 나옵니다. 

시간관계상 충분하게 설명 못 드리는 점도 미리 죄송하다는 말씀을 드리고요.

하지만 놓치거나 모르는 게 나와도 걱정하실필요는 없습니다.

오늘 달았던 소스코드와 발표자료는 인터넷에 그대로 올려드릴 겁니다.

그리고 제 메일 주소로 연락주시면 제가 언제나 실시간 답변을 드리겠습니다.

첫 번째요. 파이썬 실행과정을 설명드리겠습니다.

파이썬 실행과정은요. 

총 크게 5가지 과정으로 되어 있고 소스코드를 읽어서 단어와 문법 분석을 해서 소스코드를 트리구조로 뽑아냅니다. 

그렇게 나온 트리로 바이트코드를 생성하고 마지막으로 그 코드를 실행해서 동작하는 그런 구조입니다.

여기 계신 분들 중에 자바 하셨던 분도 계실 것 같은데요. 

이 파이썬이 자바와 똑같은 실행과정을 거칩니다.

그런데 이상하죠? 자바는 컴파일러인데요.

그래서 제가 파이썬홈페이지에 들어가서 파이썬은 무엇인가 하는 문서를 열어보니까 

딱 첫 줄에서 파이썬은 인터프리터라고 소개하고 있습니다.

공식적으로 확인받았습니다.

요즘은요. 또 컴파일러와 인터프리터의 실행과정이 많이 비슷합니다. 

차이점은 실행시점과 타입구성입니다.

그리고 예외적으로 동적 타이핑이 되는 것도 있습니다.

이번 페이지는 작업계획과 개발환경 세팅입니다.

파이썬 실행과정인데요.

저렇게 가상머신을 뺀 전부를 바꿔야 합니다. 

이제 자세히 살펴보겠습니다.

1번은 당연히 소스코드에 switch문이 들어갈 거고요.

2번 어휘분석은 switch문에 들어간 키워드를 분석하는 작업입니다.

3번 구문분석은 switch문을 인식하고 구문트리를 만드는 작업입니다.

4번은 그렇게 해서 바이트코드를 생성합니다. 

그게 나오면 완료된 것이고요. 5번은 실행만 하면 되는 겁니다.

저런 과정의 작업을 하기 위해서는요. 

위와 같은 재료가 필요하고요.

제 경험으로는 소스코드하고 좀 끈기 이런 게 필요합니다.

C언어로 만든 파이썬 구현체를 C파이썬이라고 부르고 있습니다. 

C파이썬은 파이썬 그 자체라고 해도 무방하고요.

소스코드는 깃탑에 올라가 있습니다. 깃허브에.

그리고 제가 작업했던 내용은 전부 저 깃허브 링크에 올라가 있습니다.

개발환경 차례입니다.

파이썬 소스코드를 받아보시면 알겠지만 

안에 메이크 파일과 뭐 이런 리눅스 관련된 빌드 파일이 있는데요.

그래서 리눅스에서만 빌드될 것 같습니다. 

그런데 놀랍게도 비주얼 스튜디오에서 빌드할 수 있는 방법이 있습니다.

그렇게 하려면요. 

파이썬 노트 폴드에 들어가서 피씨빌드라는 필드에 들어갑니다.

솔루션 파일을 열면 비디오스튜디오가 뜰 겁니다.

시작이 반이라는 말이 있듯이 여기까지만 열리면 저희는 반은 성공한 겁니다.

프로젝트 중에서 윈도우에서 빌드된 건 그렇게 많지 않습니다. 

그런데 인터프리터와 관련된 건 모두 빌드가 잘 되기 때문에 큰 문제 없이 진행할 수 있었습니다. 

이제 switch문 넣을 준비는 다 끝났습니다.

첫 번째 작업으로 파이썬 구문분석기를 만들겠습니다.

아까 구문분석 전에 어휘분석 과정이 필요하다고 말씀드렸는데요. 

하지만 요즘 파서는 합쳐서 처리합니다. 

이제 파이썬 파서를 생성하는 방법에 대해서 살펴보겠습니다.

비주얼 스튜디오 프로젝트 중에서 피젠이라는 프로젝트가 있고 

이것을 통해서 파이썬 파서 소스코드를 만들 수 있습니다.

그리고 거기에 대한 입력으로 그래머 파일이 필요한데요.

그래머 파일은 파이썬 문법구조가 정의된 일입니다. 

그래머 폴더 안에 있습니다.

그래머 파일을 열어보면 어떤 소스코드 같은 게 보입니다. 

이것은 BNF 문법으로 작성된 거고요.

이 그래머 파일은 확장된 BNF 문법으로 설명되어 있습니다. 

이제 저 문서에 switch문을 넣겠습니다.

파이썬에 넣을 switch문 문법규칙은 이렇습니다. 

switch절에는 계산식이나 값을 바로 넣을 거고요. 

값이 일치하면 해당본문을 실행하게 될 것입니다.

그리고 전부 일치하지 않으면 S절을 실행하는 규칙입니다.

방금 말씀드린 switch문 규칙을 BNF로 바꾸면 다음과 같습니다.

설명드리겠습니다.

컴파운드 스테이트먼트부터 설명드리겠습니다.

파이썬에 쓰이는 여러 문장구조를 의미합니다.

그리고 여러 문장 중에 switch문을 추가한다고 알렸습니다.

그리고 switch문의 문법은 다음과 같습니다.

switch문은 switch 키워드로 시작하고 계산식을 계산해서 저장할 것이다.

마지막에 클론과 개행문자로 종료를 알립니다.

케이스절은 케이스 키워드로 시작하고 값을 비교할 계산식과 값이 일치하면 

실행될 본문을 여러 개 만들 수 있습니다.

케이스절 같이 여러 개 만들기 위해서는 묶어둬야 합니다.

그리고 케이스절 다음에는 엘스 절이 나올 수 있고요.

하나만 쓰이거나 생략 가능한 건 대괄호 기호로 묶어야 합니다.

아래에 예제코드와 같이 무조건 실행될 것 같은 단독 엘스 절만 쓰고 싶으면 분리할 수도 있습니다.

제가 잠깐 BNF코드를 읽어드렸는데요. 

케이스절과 익셉트절 두 개 규칙이 비슷해서 이것을 참고해서 switch문 문법을 만들었습니다.

그리고 그래머파일을 작성했으니 이제 파서를 뽑아야 합니다.

아까 파서 만들 때 피젠 실행파일이 필요하다고 했는데요.

그 피젠 실행파일로 다음과 같은 인자를 놓고 실행하면 

문법오류가 없다면 소스코드가 생성됩니다.

그렇게 생성된 소스코드는 헤더와 C소스코드 두 개이며 원래 있던 소스코드와 교체하면 됩니다.

그리고 그 소스코드를 열어보면요. 

스위치 스테이트먼트가 상수로 정의된 것까지 확인할 수 있습니다.

이것을 이제 이것 그대로 파이썬 인터프리터를 빌드해서 실행합니다.

이렇게 실행된 인터프리터는 스위치문을 인식할 수 있습니다. 

그런데 파서는 다 만든 것 같습니다. 

하지만 아직 멀었습니다.

결과를 만들어야 합니다. 

파싱의 결과는 구문트리입니다. 

그래서 저희는 이제 구문트리를 만드는 차례로 넘어가겠습니다.

구문트리는 ST라고 부르기도 하는데요. 

저는 오늘 세션에서는 구문트리라고 칭하겠습니다.

ST모듈로 이리저리 바꿀 수 있습니다.

저도 이것 만지다가 문법을 바꿀 수 있다는 생각을 하고 발표까지 오게 되었는데 

진짜 그게 착각이었기 때문에 

저는 ST모드는 손도 못 대고 BNF하고 C코드만 만져서 발표하는 자리까지 오게 되었습니다.

switch문의 구문트리를 만들기 위해서는 switch문의 트리구조를 정의하는 것이 필요합니다. 

그게 파이썬.ASDL 파일이고 결과로 나옵니다.

그리고 제 경험상 역시나 여기서도 끈기가 필요합니다.

파이썬.ASDL 파일은 구문트리 모드를 정의하기 위한 파일이고요. 

switch문을 넣기 위해서 두 가지를 작업했습니다.

switch 전체, 케이스절에 대한 내용입니다.

첫 번째는 switch 노드에 대한 이야기를 해드리자면..

노드의 두 번째 인자는 switch 계산식을 저장하는 곳입니다.

세 번째 인자는 케이스절들이 들어가는 곳이고요. 

이것은 여러 개가 들어갑니다.

케이스 노드에 들어갈 첫 번째 인자는 

switch절에 있는 계산식과 비교할 계산식이 들어갑니다.

그리고 두 번째로 들어갈 인자는 케이스가 실행될 때 본문이 들어갑니다.

그리고 끝에는 해당 케이스절에 소스위치가 들어가는데 

이건 실행 중 위치를 알리는 역할도 있고 

디버깅할 때 정보를 제공하는 역할도 가지고 있습니다.

다시 스위치문 노드 구조로 들어왔습니다.

이게 마지막 네 번째 인자인데 엘스절에 있는 본문을 저장할 내용입니다.

이제 다 끝났습니다.

아까 파서와 마찬가지로 C코드를 뽑아내는 게 목표인데요. 

이번에는 실행파일이 아닌 파이썬 스크립트를 통해서 소스코드를 생성해야 합니다.

다음과 같이 넣으면 헤더파일, C소스파일이 생성됩니다.

이렇게 생성된 것을 눈으로 확인하고요.

본래 있던 파이썬 소스코드와 교체를 해야 합니다.

그리고 교체된 소스코드를 열어보면 switch문에 대한 구도체를 확인할 수 있습니다.

그런데 아직 끝이 아닙니다. 

지금까지는 자료구조만 만든 거고 이제 이걸 가지고 코드를 채워나가야 합니다.

switch문이 들어간 구문트리를 생성하는 두 번째 시간인데요.

재료는 다음과 같습니다. 

두 개는 이미 만들었고요. 

파일 하나만 작업하면 됩니다. 

오랜만에 C코딩을 시작해야 하는데 엄청 귀찮습니다.

ast.c 안에 들어가서 함수 하나를 만들어야 합니다.

목표는 switch문의 구문트리 노드를 만드는 것입니다.

이제 저 함수에서 하는 일을 하나씩 switch 예제에 맞춰 설명드리겠습니다. 

첫 번째로 케이스절 개수를 세었습니다.

그다음에는 임시변수를 만들고 심볼테이블에 등록했습니다. 

심볼테이블은 잠시 후에 설명드리겠습니다.

세 번째로 switch절에 들어가는 계산식 노드를 저장했습니다.

저 함수는 미리 만들어진 것입니다.

네 번째로 저 함수를 호출하며 리턴받았습니다.

이 함수도 이전과 마찬가지로 미리 만들어진 것입니다.

마지막으로 케이스절 노드를 만들어 저장을 합니다.

저 함수는 제가 만든 함수인데요. 

이 내용은 그냥 지나치는 점 양해 부탁드리겠습니다.

그리고 만든 노드들을 switch구조체에 뭉쳐서 리턴을 하면 이 함수는 완성입니다.

이렇게 만든 함수는요. 

저 안에 넣으면 되는데요. 

이 함수에 우리가 만든 switch문이 들어간 경우 케이스를 하나 더 호출하면 완성입니다.

이제 switch문에 대한 구문트리 생성을 확인하겠습니다. 

저 출력문이 구문트리가 나왔다는 뜻이고요. 

내용이 담겨져 있습니다. 

이렇게 switch문 구문트리 만들기도 완료했습니다.

여러분도 이제 코딩하다 말고 이 중간 단계에서 실행해본 경험이 많이 있을 것 같습니다.

구문트리도 저도 잘 나왔겠다 싶어서 한번 실행해봤습니다.

결과는 대참사였고요.

파이썬에 만든 에러가 아니고 파이썬 인터프리터 자체가 죽어버렸습니다.

이 디버깅에 가장 많은 시간을 써서 원인을 찾았는데 

바로 심볼테이블에 정보를 채우는 작업이 빠져서 그렇습니다.

이제 심볼테이블 작업으로 넘어가겠습니다.

심볼테이블은 식별자를 관리하는 곳이라고 하면 대강 맞는 뜻입니다. 

확인은 파이썬 내장함수를 가지고 할 수 있습니다.

로컬즈 함수로 지역변수를 확인할 수 있는데요. 

예제와 같이 바쓰리 변수가 실행되지 못했기 때문에 저장되지 않았습니다.

심볼테이블 작업은 소스코드 한 군데만 고치면 되는 상대적으로 간단한 작업입니다.

여기에 들어오면 많은 케이스 분기가 있습니다. 

우리는 이 케이스를 하나 만들어서 

switch문에서 식별자가 쓰일 곳을 하나씩 찾아서 매크로를 호출해야 합니다.

첫 번째로 switch절 계산식에는 변수나 함수가 들어갈 수 있기 때문에 매크로를 확장하였습니다.

두 번째 케이스절에서도 변수나 함수가 호출될 수 있기 때문에 

visif-seq 매크로를 확장해야 합니다.

본문에는 당연히 함수와 변수가 많이 있기 때문에 

심볼테이블 확장이 필요합니다. 

그래서 비짓시퀀스 매크로를 불렀습니다.

이제 실행해보겠습니다. 

실행이 잘 되었다면 심볼테이블에 변수가 들어갈 것입니다.

이제 실행을 해보면요. 

심볼테이블에 변수가 들어간 것을 확인할 수 있고요. 

심볼테이블 작업이 완료된 것까지 확인하였습니다.

스위치문도 인식하고요. 

심폴테이블 등록까지 했습니다. 

이제 바이트코드를 채워서 실행하는 과정만 남았습니다.

바이트코드 생성하기입니다.

파이썬 코드를 실행만 하면 그냥 많이 생성되는 거 있죠. 

PYC 파일요. 

그게 컴파일된 파이썬 코드가 들어가 있습니다. 

그리고 dis 모듈로 여러 가지를 할 수 있습니다.

바이트코드는 파이썬 가상머신을 실행하는 명령어와 데이터로 되어 있는데요. 

파이썬 가상머신은 현실의 지표보다 훨씬 더 단순한 소프트웨어 코드입니다. 

그래서 159개의 명령만 가지고 프로그램을 실행시킵니다. 

그런데 이건 저희한테는 그렇게 단순한 숫자는 아닙니다.

다행인 점은 이번 switch문에는 6개의 바이트코드만 사용했습니다.

이번 과정의 자료는 저런 소스코드이고요. 

참고문서는 인터넷상에서 가장 바이트코드에 대한 내용이 잘 나와있는 문서입니다.

저 소스코드에 들어가서 함수 하나를 정의합니다. 

함수가 하는 일은 switch문의 바이트 코드를 만들기 위한 함수입니다. 

실행과정을 보여드리겠습니다.

첫 번째로 switch절 계산식에 바이트코드를 뽑는 과정입니다. 

미리 정의된 매크로에 계산식 노드를 인자로 넣으면요. 

저 생성대상에 있는 빨갛게 표시된 부분에 계산식을 순회하면서 바이트코드를 생성합니다.

다음 단계로 계산식의 결과를 변수에 저장하는 바이트코드를 생성합니다.

컴파일러-네임오프 함수에 하면 바이트코드가 생성됩니다.

case 절에 대한 바이트코드를 생성하기 전에 개수를 확인해야 합니다.

매크로를 확장해서 개수를 셀 수 있습니다. 

그리고 그 개수만큼 바이트코드 생성을 반복합니다.

케이스절 바이트코드 생성으로 들어왔습니다. 

switch 계산식과 같은 방법으로 케이스절 계산식 노드를 비짓 매크로에 인자로 넣으면 

저기 빨간메모로 표시된 바이트코드가 생성됩니다.

이제 switch절 계산결과를 저장했던 변수를 불러서 비교를 해야 합니다. 

컴파일러 네임오프 함수를 통해 바이트코드를 생성합니다.

이렇게 케이스절 계산식과 임시변수를 비교할 때는 비교연산 바이트코드가 생성이 되어야 합니다.

ADDOP-K 매크로에 인자로 놓고 바이트코드를 생성하면 됩니다.

비교를 했는데요. 

값이 다르면 다음 케이스로 이동을 해야 합니다. 

이동을 뜻하는 앱솔루트점프 매크로를 사용해서요. 

첫 번째는 비교가 실패하면 점픗한다는 조건을 놓고 매크로를 실행하여 해당 바이트코드를 생성합니다.

그리고 비교가 참이면요. 

실행될 본문에 바이트코드 생성은 비짓시퀀스 매크로를 가지고 할 수 있습니다. 

매크로를 실행하면 해당 공문, 즉, 생성대상에서 빨간 네모로 표시한 부분을 순회하면서 바이트코드를 생성합니다.

이렇게 본문실행이 끝나면 다른 케이스절과 엘스절을 건너뛰어야 합니다. 

위치는 switch문 마지막으로 정하고 

이번에는 매크로를 사용해서 switch문 마지막으로 점프하는 바이트코드를 생성합니다.

케이스절에 대한 생성 설명이 끝났습니다.

이제 else절 본문 노드를 인자로 넣고 비짓시퀀스 매크로를 생성하면 

본문노드를 순회하면서 바이트코드를 생성합니다. 

이제 다 끝난 것 같은데요. 

아직 남은 게 있습니다. 

아까 제가 점프한다고 말씀을 드렸는데 점프할 위치가 결정이 안 되었습니다.

컴파일러 유저 넥스트 블록 함수를 호출하면 

점프할 위치가 바이트코드 주소로 바뀌게 됩니다.

그리고 마지막으로 청소 작업이 필요합니다. 

임시변수가 되었는데 이제 제거해야 합니다.

컴파일러 네임오피 함수에 넣고 호출하면 필요없어진 변수를 제거하는 바이트코드를 생성합니다.

이제 이것을 호출하는 코드로 이동하겠습니다.

컴파일.c 안에 컴파일러 비짓 스테이트먼트 함수는 여러 문장을 선택하는 스위치 분기문이 있습니다. 

여기에 우리가 만든 함수를 호출하도록 해야 합니다.

그러면 문장 중에 switch문이 있으면 만들었던 함수를 호출할 수 있게 됩니다.

바이트코드 생성까지 다 끝났는데 이제 디스어셈블러 모듈로 switch문에 대한 바이트코드를 확인하겠습니다.

모두 확인할 수 있습니다. 

이제 이것을 실행하는 과정으로 넘어가겠습니다.

열심히 코딩했던 보람이 있기를 바라면서 실행해보겠습니다.

switch절 계산 결과가 랜덤이기 때문에 아무 거나 선택하게 되었는데 

첫 실행에 두 번째 케이스가 실행되었습니다.

두 번째 실행은 엘스절 본문이 실행되었습니다. 

계속해봤습니다.

골고루 여러 번 실행되는 걸 보니 switch문이 완성되는 느낌입니다.

그리고 자랑거리가 또 하나 있는데요. 

이 switch문은 디버거에도 적용할 수 있습니다.

이걸 보시면 알겠지만 두 번째 케이스를 실행하는 디버깅 애니메이션을 볼 수 있습니다.

다들 여기까지 들어주셔서 감사하고요. 

제가 좋아하는 마무리 부분으로 넘어가겠습니다.

힘든 과정을 거쳐서 파이썬에 switch문을 넣었습니다. 

저는 이번 발표를 통해서 여기 계신 분들이 C파이썬 커스텀 버전을 만드는 걸 너무 보고 싶습니다. 

힘드신 부분이 있으면 도와드리겠습니다.

제가 발표를 구상할 때 이야기를 잠깐 드리자면 

저는 이게 멀티라인이나 뭐 패턴매칭도 만들어서 발표를 해보는 게 목표였는데 

제안서를 넣기 전에 불가능하다는 것을 알아서 다행이라고 생각하고 있습니다.

발표자료를 넣어버렸으면 불상사가 생길 뻔 했습니다.

그리고 만들면서 느꼈던 점인데요. 

인터넷에 파이썬 문법확장에 대한 검색을 하면 딱 하나만 나옵니다.

그래서 오늘 발표가 두 번째 자료가 될 것 같은데요. 

의도하지는 않았지만 가장 기능과 설명이 많이 들어간 자료가 될 것 같습니다.

그런데 기능이 많이 들어간 게 오히려 발표의 집중력을 떨어뜨리고 

세션의 난이도가 많이 올라가게 해서 이게 독으로 작용한 것 같아서 좀 아쉬운 마음이 있습니다.

만약 제가 내년에 다시 발표를 하게 된다면 

훨씬 쉬운 난이도와 더 재미있는 주제로 찾아서 발표하도록 하겠습니다.

그리고 심볼테이블 이슈는 저만 고생한 것으로 끝났으면 좋겠습니다. (웃음)

제 욕망과 후회입니다.

세션 제목을 파이썬에 GOTO문 넣기로 하고 싶었습니다.

그리고 고토문이나 비난을 받는 자리로 만들어보고 싶었는데 생각만 하고 끝났습니다.

작업 중에 오늘 작업했던 내용이 아닌 여기 있는 기능들에 소스코드를 봤는데 

저런 부분을 만드는 것은 어떨까 생각도 많이 해봤습니다.

그런데 생각은 제가 하고요. 

만지는 것은 여기 계신 누군가가 해주셨으면 좋겠습니다.

(웃음)

영업의 시간인데요. 

저는 파이썬이 2년밖에 안 돼서 파이썬 꿈나무입니다.

그래서 저희 회사에 계신 분들만큼 실력은 없지만 

저 말고 회사에 계신 분들은 배울 게 많고 재미있는 분들이 많이 계십니다.

그리고 여기 계신 분들은 최고의 파이썬 프로그래머죠. 

저희 왓 스튜디오에 와주시면 정말 환영하고 감사드리겠습니다. 

파이썬을 안 하셨더라도 괜찮습니다. 

관심만 가지셨던 분들도 훌륭한 파이썬 프로그래머가 되어 있습니다. 

그리고 취업힌트나 이런 게 있으면 저한테 물어봐주시면 친절히 답변드리겠습니다. 

아침 일찍 와주셔서 감사합니다.