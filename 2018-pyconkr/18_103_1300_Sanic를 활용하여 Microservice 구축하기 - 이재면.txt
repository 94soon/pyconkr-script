안녕하세요.

이번 세션의 발표를 맡게 된 이재면입니다.

뒤에 잘 들리시나요?

저를 먼저 간단하게 소개하면요.

저는 마이뮤직테이스트 팀에서 일하고 있습니다.

뭔가에 빠져서 하는 매니아가 되고 싶은 사람인데요.

개발자분들이 개발을 더 편리하게 할 수 있는 환경을 구축하기 위해서 노력하고 있습니다.

그리고 저 사진에 보이는 두 강아지와 함께살고 있는 집사이기도 합니다.

오늘 이렇게 귀한 주말 시간에 제 세션에 와주셨는데요.

조금이라도 배워갈 수 있는 발표가 되었으면 좋겠습니다.

혹시 Microservices를 만드시거나 하시는 분들이 있으시면 손 한번 들어봐주시겠어요? 감사합니다.

그리고 asyncio 개발해보신 분도 손 들어주세요.

감사합니다.

제 강연을 듣는 여러분들이 이런 정보를 얻어가셨으면 하는데요.

먼저 Microservices architecture는 무엇인지.

그리고 우리는 왜 Microservices architecture를 해야 하는지.

낯서신 분들은 기본적인 개념을 가져가시길 기대합니다.

그리고 왜 많은 회사들이 이렇게 Microservices architecture로 전환하는지에 대한 인사이트 또한 함께 가져가려고 합니다.

다음으로 Microservices 어떻게 구축했는지를 위해서 파이썬과 asyncio를 활용해서 하는 회사가 있구나.

이 회사는 이렇게 하는구나하고 참고할만한 사례가 되었으면 좋겠습니다.

제 발표 목차는 먼저 Microservices에 대해서 이야기하고요.

다음으로 Async와 Sanic에 대해서 간단하게설명을 드리겠습니다.

그리고 사내에서 개발중인 인새닉에 대해서 말씀드리고요.

마지막으로 Microservices architecture에 대해서 말씀드리면서 챌린저와 앞으로의 이야기를 드리겠습니다.

질문이 있으신 분들은 발표가 끝나고 찾아와주시면 최선을 다해서 답변드리도록 하겠습니다.

그러면 첫 번째를 챕터를 시작하겠습니다.

Microservices란 무엇일까요? Microservices architecture의 장단점은 Monolithic application를 비교하겠습니다.

Monolithic application는 하나에서 모든 기능이 들어있는 거를 생각하시면 되는데요.

웹 프레임워크로 개발하면 이렇게 Monolithic application가 형태가 되게 됩니다.

Microservices architecture는 이름에서 힌트를 얻을 수 있다시피 작은 서비스로 나뉘고 그 작은 서비스들이 커뮤니케이션하는 방법으로 작동하게 되는데요.

단순하게 설명드리면 이렇게 사용자관리, 상품관리, 배송관리, 리뷰관리 기능이 있습니다.

그러면 Microservices architecture에서는 사용자관리 서비스 따로, 배송관리 서비스 따로, 리뷰관리 서비스 따로, 상품관리 서비스 따로 존재하게 되고요.

그들간에 서비스간에 통신을 하게 됩니다.

오늘 위키피디아에서는 Microservices architecture에 대한 특징을 설명하는 내용을 하나씩 살펴 보려고 하는데요.

먼저, 에이컬렉션 루슬리..

이렇게 나뉘어진 서비스는 약하게 결합된 구조라고 할 수 있습니다.

그리고 모어위즐린~는 이렇게 나뉘어진 서비스들은

하나의 어플리케이션에 모든 기능이 있기 때문에 일부분에 장애가 발생하면 전체 프로그램이 셧다운 될 수 있는데요.

Microservices에서는 서로 독립적으로 존재하고 일부분의 서비스가 장애가 있다고 하더라도 시스템 전체가 셧다운이 되지 않는 구조가 됩니다.

그리고 스케일~ 인피덴던틀리는 전체 어플리케이션에서 스케일업을 해야 되는데요.

Microservices는 서비스별로 독립적으로 스케일업을 할 수 있게 됩니다.

예를 들어서 리뷰관리에 트래픽이 엄청 몰린다고 하면 Monolithic application는 전체 어플리케이션를 스케일업해야 되는데요.

Microservices는 리뷰관리에 대한 서비스만 독립적으로 스케일업을 할 수 있는 구조가 됩니다.

그리고 폴리글랏은 다양한 언어로 서비스를 만들 수 있는 특징인데요.

예를 들어서 상품 관리는 Go로 만들고 리뷰관리는 파이썬으로 만들 수 있게 됩니다.

왜냐하면 서로 서비스는 독립적으로 존재하고 커뮤니케이션을 통해서 작동할 수 있는데요.

예를 들어서 장고나 루비로는 이렇게 구성하기가 힘듭니다.

이렇게 Microservices architecture는 서비스별로 다른 기술 스택을 도입할 수 있기 때문에 서비스별의 특징에 맞춰서 기술스택을 선택할 수 있고 상대적으로 새로운 기술을 적용하기가 용이합니다.

마지막으로 패러다이즈~ 운영를 하다보니 작은 팀들이 각 서비스들을 독립적으로 담당하여 개발이 이루어질 수 있습니다.

많은 회사들이 커지는 서비스와 커지는 개발팀을 운영함에 있어서 이러한 점이 유리하게 작용하지 않을까 저는 생각합니다.

그리고 엉켜있는 거대한 모노를 이해하는 것보다 서비스를 담당하는 팀들은 자기의 서비스의 로직과 코드들만 파악하면 되고.

Monolithic application에서 작은 기능을 추가하더라도 전체를 테스트를 해야 되는데요.

Microservices는 각각 독립적으로 테스트를 진행할 수 있습니다.

그리고 컨테이너를 쉽게 활용할 수 있는 게 있고, 오케스트레이션 툴들이 활용되면서 Microservices architecture장점들을 극대화할 수 있게 되었습니다.

각 서비스들이 컨테이너를 존재하고 오케스트레이션 툴들로 이러한 컨테이너들은 여러 서버에서 좀 더 편리하게 운영하게 되었는데요.

Microservices architecture의 성공적인 운영사례로 넷플릭스와 아마존이 많이 언급이 됩니다.

이렇게 언급이 되면서 하루에도 수십번 배포를 한다고 설명을 하고 있는데요.

하루에도 수십번 배포한다는 것은 어떤 의미가 있을까요?

이렇게 잦은 배포는 고객들에게 개선된 기능, 혹은 새로운 기능을 빠르게 제공할 수 있다는 것을 의미하고요.

이렇게 고객의 입맛에 맞는 기능을 제공함으로써 고객을 만족시킬 수 있고, 고객의 만족은 결국 비즈니스 성공으로 이어질 수 있습니다.

이러한 잦은 배포환경에는 서비스별로 개발하고 다이나믹하게 운영될 수 있는 Microservices가 적합하다고 생각합니다.

지금까지 특징을 말하면서 장점들만 말한 것 같은데요.

Microservices architecture는 그 자체로 더 많은 복잡성을 가지고 옵니다.

테스트, 데이터일관성, 모니터링 등 많은 부분에서 복잡도가 증가하게 되는데요.

이러한 복잡을 해결하기 위해서 그만큼 리소스도 들어가게 되고요.

시스템이 Monolithic application로 관리하기 어려울 정도로 복잡해지기 전까지는 Microservices는 생각도 하지 말라고 하면서 그냥 Microservices architecture를 무작정 예찬하고, 도입하는 것을 경고하고 있습니다.

그럼 저희는 왜 Microservices architecture로 전환하였을까요? 저희도 처음에는 Django로 개발하여 Monolithic application로 운영되어 왔습니다.

그런데 점점 서비스가 확장되면서 관리의 어려움을 느끼기 시작했는데요.

런서버하는 데만 15초가 넘게 걸리게 되고 바쁘게 기능들을 추가하게 되니 서로 엉켜져있는 Monolithic application가 되어 왔습니다.

그러면서 기능들을 새로 추가하거나 하는 것이 부담스럽고 어려워지기 시작했고요.

서비스 확장, 개발팀의 확장과 함께 Microservices architecture로 전환을 결정하게 되었고.

최근 8월 6일날 새로운 아키텍쳐로 서비스를 늘리자하게 되었습니다.

이제, 되게 길게 첫 번째 챕터에서 왜 저희가 Microservices architecture로 전환하였는지 설명드렸는데요.

그러면 이제 Microservices를 어떻게 구축하였는지 설명을 드리겠습니다.

파이썬으로 Microservices를 만들면서 asyncio가 되었습니다.

간략하게 asyncio를 설명드리면 파이썬 3.4부터 제공되는 모듈인데요.

이처럼 이렇게 시퀄스하게 합니다.

예제코드를 가지고 왔는데요.

async future라는 걸로 감싸서 이벤트에서 concurrent하게 됩니다.

잠시 중단했다가 그 시점에서 다시 실행하는 것을 여러 번 반복하게 해 주는데요.

오늘 파이콘에 coroutine만 집중적으로 하는 곳이 있더라고요.

그 세션을 추천드립니다.

저도 들으려 가려고 합니다.

그리고 도큐먼트에서 설명하고 있는 시퀀스 다이어그램을 보면 이벤트에서 어떤 시퀀스가 실행이 되고 다시 이벤트에서 해당 작업으로 돌아가서 완료하고 이벤트로 돌아오는 걸 볼 수 있는데요.

여기서 중요하게 볼 거는 1초가 슬립이 되는 동안 다른 테스트가 실행이 될 수 있다는 것입니다.

Async 라이브러리에서는 다음과 같은 거를 쉽게 실행할 수 있게 해 주는데요.

다 완료되면 결과를 취합해서 돌려줄 수도 있습니다.

두 번째처럼 여러 개를 실행하고 제일 먼저 끝나는 게 있으면 사용하고, 나머지는 구현할 수 있고요.

세 번째처럼 스케줄에 등록하고 결과값을 기다리지 않는 형식으로 구현할 수도 있습니다.

네 번째는 실행되어야 하는 값을 지정할 수 있습니다.

저희는 많이 사용하게 되는데요.

asyncio는 실행할 수 있게 해줍니다.

여기서 여러 가지 일을 번갈아가면서 수행할 수 있는 거를 말하는데요.

concurrent하게 돌아가기 때문에 하나가 여러 가지 일들을 번갈아가면서 한다고 생각할 수 있습니다.

이벤트룸에 컨퍼런트를 넘겨주면 다른 테스트로 넘겨가서 일을 할 수 있습니다.

하지만 만약 비가 협조적이지 않고 독점하고 있다고 하면 에이는 마냥 기다릴 수 밖에 없게 되고요.

그래서 기존에 작동하는 라이브러리를 그대로 사용할 수 없고 asyncio로 해서 비동기적으로 작동할 수 있는 라이브러리가 필요합니다.

여러 가지 일들을 번갈아가면서 하기 때문에 씨피유바운드에서는 할 수가 없고요.

아이오바운드에서는 장점을 보일 수 있게 됩니다.

앞에서 설명한 것처럼 Microservices architecture는 서비스별로 나뉘어존재하고 서로 통신을 하게 되어 있습니다.

Microservices architecture에서 일반적으로 HTTP와 같은 프로토콜을 사용해서 서비스가 통신을 하게 되는데요.

동기로 처리하게 되면 여러 개를 할 때 하나씩 해야 하는 문제가 생깁니다.

Microservices architecture로 구현하면서 퍼포먼스로 하는 비동기처리가 필요했고요.

3.4부터 스탠다드 라이브러리로 제공되는 asyncio를 활용하기로 했습니다.

하지만 처음부터 웹 프레임워크를 하는 것은 비효율적이기 때문에 이미 존재하는 오픈소스를 하게 되었고.

서버도 있었는데 그 당시에 좀 더 빠르고 안정적이라고 생각했던 Sanic를 활용하기로 결정하였습니다.

Sanic은 파이썬 웹생태계에서 한축을 이루고 있는 Flask랑 상당히 비슷한 구조를 보이고 있는데요.

Sanic 도큐먼트에서 Flask 웹 서버라고 할 정도로 되게 비슷합니다.

오른쪽에 코드처럼 간단하게 JSON형태의 서버를 만들 수 있습니다.

Sanic에서 어떻게 70피 서버를 만들고 있는지 간단하게 확인을 해볼 건데요.

asyncio에서는 한쌍으로 제공하고 있습니다.

루프에서 데이터를 프로토콜로 푸쉬하고 하는데요.

이렇게 프로토콜로 할 수 있게 하여 줍니다.

Sanic에서 asyncio의 프로토콜을 상속받아서 사용하는 것을 볼 수 있는데요.

커넥션 메이드, 머스트는 트랜스에서 하는 콜백입니다.

콜백만 봐도 어떤 이야기를 하는지 대략 할 수 있겠습니다.

데이터를 받아서 여러 가지 컨트롤 작업을 하고 트랜스포터로 데이터를 되돌려보는 것을 볼 수 있는데요.

오른쪽처럼 HTTP 프로토콜 인스턴스 서버를 다른 서버로 인자를 넣고 서버를 생성하고 있습니다.

Sanic은 저희가 처음부터 asyncio를 활용하여 웹 프레임워크를 구축할 필요없이 편리하게 할 수 있게 하여 주었습니다.

하지만 저희가 Sanic를 활용함에 있어서 추가적인 기능이 필요했고요.

그래서 이번 챕터에서는 저희가 어떤 기능들이 추가적으로 필요했고 왜 인새닉이라는 거를 사용하게 되었는지 설명드리고자 합니다.

먼저 저희는 스타트업입니다.

적은 리소스를 가지고 Microservices architecture를 구축해야 되는데요.

그래서 개발자들이 서비스 로직에 좀 더 집중할 수 있도록 사내 웹 프레임워크를 개발하여 공통적으로 사용하였습니다.

처음 챕터에서 제가 Microservices architecture특징 중에 폴리글랏을 설명드렸는데요.

적합한 기술 스택을 별도로 적용할 수 있는 특징이었습니다.

이렇게 파이썬으로 작성된 사내 웹 프레임워크를 공통적으로 사용한다는 것은 그러한 폴리글랏의 장점을 포기하는 건데요.

하지만 저희가 적은 리소스가 있는 상황에서 서비스별로 다른 거를 도입하다보면 운영하기에 힘든 점이 발생할 수 있습니다.

그리고 같은 스탯으로 개발하다보면 저희가 맞닥뜨리는 문제들을 개발자 전체가 쌓인 노하우나 지식들을 공유해가면서 해결해 나가기가 더 쉬울 것입니다.

그래서 인새닉을 개발해서 진행을 하게 되었고요.

인새닉을 개발하면서 Django와 Django 프레임워크를 하게 되었습니다.

인새닉에서는 Django처럼 세팅을 언제든지 사용할 수 있게 하였고요.

그리고 저희는 서비스가 필요한 시크릿 관리를 볼트로하고 있습니다.

따라서 당연히 인새닉에서 필요한 세팅들을 몰트에서도 가져와야 되고.

그래서 볼츠에서 해당 시크릿을 가져와 세팅해서 사용할 수 있도록 추가하게 되었습니다.

다음으로는 Django Rest 프레임워크를 적용하는 방법인데요.

추가할 수 있도록 하였습니다.

어떤 뷰는 서비스만 접속하면 할 수 있고, 어떠한 뷰는 로그인 유저만 볼 수 있는 뷰가 있을 수도 있는 등 다양한 경우가 있는데요.
개발자들은 해당되는 퍼미션클래스만 추가하여 간단하게 구현할 수 있도록 하였습니다.

이것도 이제 Django 프레임워크를 하여 수정하였습니다.

기본적으로 데이터를 가져올 수 있고요.

인새닉은 애당초 Microservices를 만드는 웹 프레임워크를 모토로 출발했기 때문에 어떤 것에서 오는 리퀘스트인지 알 수 있게 하였습니다.

Microservices architecture에서 서비스간에 통신이 많을 수 밖에 없는데요.

개발자들이 개별적으로 다른 서비스콜을 하기 위한 로직을 매번 작성하는 거는 비효율적이라고 생각했습니다.

그래서 서비스플랫을 만들어서 개발자들이 공통적으로 사용할 수 있도록 했고요.

서비스가 통신에서 유아 서비스라는 거를 확인하기 위해서 토큰 생성하고 서킷 브레이커가 작동할 수 있도록 하였습니다.

서비스 에이에서 비로 리퀘스트하는 과정에서 서비스 비가 죽어있으면 죽은 서비스에게 계속 리퀘스트를 하는 것이 아니라 서킷브레이커에서 감지해서 죽은 거에다가 리퀘스트를 보내지 않게 됩니다.

이밖에도 저희는 파이테스트를 통해서 유닛테스트를 하고 있는데요.

공통적으로 테스트하기 위한 피쳐들, 인새닉에서 제공하고요.

테스트 과정에서 다른 서비스를 오킹하는 경우가 있는데 오킹할 때 클래스 제공도 하고 있습니다.

저희는 오픈소스인 홈을 사용하고 있습니다.

그래서 등록하는 것을 인새닉에서 관리할 수 있게 하였고요.

트레이싱을 AWS X-Ray서비스를 사용하고 있습니다.

활용해서 트레이싱을 온오프할 수 있도록 하였습니다.

그밖에도 여러 가지 기능을 추가하려고 작업 중에 있는데요.

서비스간에, 또 도큐먼트를 코드상으로 제너레이트해 주는 기능, 또 추가로 적용할 수 있도록 작업하고 있습니다.

마지막으로 이렇게 Microservices architecture를 구축하면서 맞이한 챌런지와 계획을 설명 드리겠습니다.

파이썬과 Asyncio를 활용해서 서비스를 개발하면서 Async하게 활용할 수 있는 많은 라이브러리가 있었고요.

이런 라이브러리를 활용함으로써 저희는 개발속도를 늘릴 수가 있었습니다.

하지만 개발을 하면서 이렇게 Async하게 사용할 수 있는 라이브러리가 없는 경우도 있었고요.

그래서 초기에 아이오를 발견하기 전에는 저희가 별개로 맵핑을 해서 만들어서 사용했고.

아이오 노트콜을 활용해서 기존에 파이논을 랩핑해서 사용하고 있습니다.

서킷 브레이커도 파이브레이커를 사용하고 있는데요.

Async하게 사용할 수 있도록 수정해서 사용하고 있습니다.

이렇게 없는 경우에는 저희가 직접적으로 Async하게 작동할 수 있도록 수정을 해서 진행을 해야 되는 경우가 있었습니다.

마틴 파울러의 그래프를 초기에 인용했었는데요.

프로덕티비티의 상관관계 그래프입니다.

시스템의 복잡도가 일정 수준 높은 상황에서 Microservices architecture가 Monolithic application보다 생산성이 높아진다는 것을 의미하는 건데요.

사실 Microservices architecture의 프로덕트에 대한 거는 논란이 많습니다.

하지만 서비스도 커지고 개발조직이 커지는 상황에서 이렇게 Monolithic application로 운영하는 것은 한계점이 많습니다.

저희는 이 그래프에서 어느 위치에 있는지 개인적으로 생각을 해보았는데요.

Monolithic로 운영하기는 어려워지는 시스템으로 넘어가는 시점이 아닐까 생각합니다.

하지만 Microservices의 전환은 정말 많은 리소스가 필요했고 많은 시행착오가 있었습니다.

현재에도 모니터링, 테스트, 서비스간의 설계에 있어서 추가해야 하고 개선할점이 상당히 많습니다.

파이썬과 파이썬 커뮤니티를 통해서 전세계에 있는 음악팬들에게 행복을 전달하는 서비스를 만들 수 있었는데요.

따라서 다양한 경로로 파이썬 생태계에 기여하고자 합니다.

그래서 이번 파이콘의 스폰서로 참가도 하였고 이렇게 개발자들이 Microservices architecture를 전환하는 경우를 나누고자 이 자리에 오게 되었고요.

비슷한 위치에 있는 스타트업에서 Microservices architecture으로의 전환을 고려할 때 저희의 이야기가 조금이나마 참고할 만한 경험이 되었으면 좋겠습니다.

실제로 프로덕션에서 운영하면서 발생하는 이슈, 더 필요한 기능들을 추가하고, 정리하여서 올해 말까지는 사내 웹 프레임워크인 인새닉을 오픈소스로 할 예정이 있고요.

인새닉을 저희 회사의 방진 님이 메인으로 관리하고 있습니다.

이를 위해서 열심히 작업을 하고 계십니다.

앞으로도 계속 다양한 경로로 저희의 시행착오와 경험을 공유하고자 하고요.

마지막으로 마이뮤직테이스트는 전세계의 음악팬들에게 행복을 전달할 개발자분들을 모시고 있고요.

확인해 주시면 감사하겠습니다.

오늘 발표를 들으러 와주셔서 감사합니다.
