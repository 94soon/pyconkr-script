안녕하세요? 

네, 저는 소개받은 이한입니다.

발표에 앞서 제 광고를 조금 하자면요.

저는 작년에도 한번 발표를 했었고요. 

올해도, 작년에도 이런 말을 했었는데 휴학을 하고 회사에서 일을 하고 있습니다. 

우선 발표에 앞서 잠시 말씀을 한 가지 드리자면 

사실 저는 아직 컴파일러에 관한 수업을 학교에서 듣지 못했습니다. 

그래도 듣기 전에 개념은 조금 알고 있었는데 

계산 이론이나 오토마타 이런 세부적인 내용들은 제가 아직 알지 못합니다.

그런 학부생이 만든 컴파일러를 개발하는 과정에서 겪은 일들에 대한 포멀한 내용이고요. 

그래서 2.6 정도의 난이도를 생각하고 있었는데 

그래서 조금 많이 어려운 걸 생각하셨다면 

그 점에 대해서는 충족을 못 시킬 수 있다는 점 먼저 양해를 드리고 시작하겠습니다.

시작에 앞서 잠깐 컴파일러에 대해서 이야기를 하고 싶습니다.

사실 컴파일러를 모르는 분들은 거의 없으실 거라고 생각을 하는데요. 

이 이야기를 하는 이유는 컴파일러는 사실 정의만 따지면 소스코드를 타겟코드로 옮겨주는 걸 말합니다.

그래서 파이썬에 투투쓰리 라이브러리도 사실 컴파일러라고 볼 수 있죠.

그래서 컴파일러를 몇 가지로 구분해볼 수 있죠.

제가 오늘 다룰 주제는 스티티 컴파일러 입니다.

이제 컴파일러에 관한 슬라이드나 책 같은 걸 보면 이런 표현이 어김없이 등장합니다.

컴파일러 과학은 컴퓨터과학의 소우주, 혹은 축소판이라고 하는데요.

제가 발표를 준비하면서 몇몇 분들께 왜 파이썬으로 만드냐는 질문을 받았습니다.

사실 파이썬이 다른 컴파일러 구현에 유리하다고 하는 

오카멜 같은 함수형 프로그래밍 언어에 비해 가지고 있는 특별한 장점은 없습니다.

하지만 제가 이 컴파일링 작업을 시작하고 올해 6월 마감일날 딱 성과를 냈어요.

그래서 이제 발표준비를 하면 

배수의 진을 치지 않으면 아무것도 안 하겠구나 하고 발표를 하기로 했습니다.

그래서 왜 파이썬으로 했냐 하면 

우선은 제가 만든 컴파일러가 이무기이고 

이 이무기의 소스코드는 이무기가 컴파일 하려고 시도하는 언어는 파이썬입니다.

이무기는 파이썬으로 만든 파이썬 컴파일러이며 

파이썬 컴파일러니까 이왕이면 파이썬으로 짜보자고 생각하였습니다.

조금 더 구체적인 기술적인 이야기로는 

제가 해결하고 싶었던 문제는 레퍼런스 카운트였습니다. 

C파이썬에서 처음에는 레퍼런스 카운트를 지우고 만들어볼까 생각을 했는데 

소스코드를 보니까 레퍼런스 카운트가 1일 때만 동작하는 여러 작업들이 있어서 

해당 부분을 제거하는 데 실패를 했고 

그렇다면 레퍼런스 카운트 증감을 줄이는 방법은 어떨까 생각해서 

그러면 컴파일러에 도움이 되겠다. 생각했습니다.

사실 이런 게 필요하다고 이야기하실 수는 있겠는데 

저희가 도구가 망치밖에 없으면 모든 문제를 못으로밖에 못 보잖아요. 

그래서 좀 더 괜찮은 새로운 도구가 있으면 

더 파이썬을 널리 있을 수 있지 않을까? 하는 마음가짐도 있었습니다.

그런데 본격적으로 이런 생각을 마음먹게 된 이유는 

올해 4월에 재미있는 프로젝트가 하나 올라왔습니다. 

시비C라는 라이브러리인데 전체가 파이썬3로 작성된 것을 보고 가능하겠다는 생각이 들더라고요.

이게 실제 동작한 모습인데 아주 컴파일이 잘 되는 걸 확인하실 수 있습니다.

그리고 더 충격적인 프로젝트도 있었는데 바로 크리스탈이라는 프로젝트입니다.

크리스털은 보시면 되게 루비 언어에 영향을 많이 받은 것 같죠. 

실제로도 밝히고 있듯이 루비에 엄청나게 영향을 받아서 만들어진 언어라고 하는데 

이 언어의 특징은 컴파일 된다는 겁니다.

실제로 네이티브 실행파일이 나오고요.

그리고 이 크리스털 컴파일러는 당연히 크리스털로 작성되어 있는데 

이 크리스털 컴파일러의 최초 버전은 루비로 작성되어 있었습니다.

그래서 그걸 보고 아, 파이썬으로도 파이썬 컴파일러를 충분히 작성할 수 있겠구나 라는 생각으로 

이 프로젝트를 시작하게 되었습니다.

사실 컴파일러는 굉장히 복잡한 도구가 맞습니다. 

하지만 정작 컴파일러를 만들려면 필요한 조건은 딱 두 가지인데요. 

첫 번째는 바이너리IO가 되어야 하고 

두 번째는 대부분의 경우에 트리구조형 표현이 가능해야 한다는 겁니다.

파이썬은 파일IO가 아주 잘 되죠. 

그리고 트리구조는 사실 AST라는 걸 표현하기 위해서 만들어야 하는데 

심지어 이게 라이브러리로도 있습니다.

그래서 파이썬은 모든 조건을 갖추고 있습니다. 

게다가 파이썬은 앞에서 설명드렸던 라이브러리들이 

메타 프로그래밍 할 수 있는 여러 도구들이 있습니다.

예를 들어서 파서에는 AST가 기본적으로 제공되고 있고요.

그래서 이를 좀만 수정하면 

파이썬 소스코드로도 충분히 파이썬을 컴파일할 수 있겠다는 생각으로 

이왕이면 바퀴를 다시 만들지 말고 있는 걸 한번 써서 해보자는 생각으로 프로젝트를 시작하게 되었습니다.

추가적으로 뭐 몇 가지 이득이 있기는 했는데요. 

우선 첫 번째 테스트에서 저는 파이썬만큼 테스트가 즐거웠던 언어는 드물었습니다.

그런데 왜 테스트를 언급하고 싶냐 하면요. 

프로그래밍 언어를 만드는 건 생각보다 컴파일되는 걸 만드는 건 그렇게 어렵지 않을 수 있습니다. 

그런데 우리가 이 컴파일된 결과물이 동작하는지 확인을 해야 하잖아요.

우리가 제일 쉽게 확인하는 방법은 프린트 함수를 보는 거죠.

그런데 프린트함수는 사실 시스템콜을 호출해야 돼요. 

그래서 생각보다 비용이 드는 작업이고 쉽사리 만들기가 어렵습니다.

그런데 이런 데에 비해서 함수의 반환값이나 이런 거는 훨씬 보기가 편하죠.

그런데 파이썬의 경우에는 C언어랑 호환성도 되고 테스트 라이브러리도 잘 되어 있어서 

중간중간 내가 잘 만들었다는 것을 확인하는 게 굉장히 편했습니다.

그리고 당연히 파이썬 문법의 이점도 있고요. 

그래서 네이티브 파이썬은 불가능한 꿈이 아니겠구나라고 생각하고 프로젝트를 시작하게 되었습니다.

복잡한 컴파일러라고 해도 컴파일러는 크게 복잡한 것, 

혹은 223같은 트랜스레이터, 등 세 가지 단계로 나눌 수 있는데요.

렉서, 그리고 토큰들을 가지고 AST라는 트리를 만드는 파서, 

그리고 해당 트리를 읽고 타겟코드를 생성하는 트랜스레이터, 혹은 코드제너레이터로 구성되어 있습니다. 

이 파서에서 코드제너레이터로 가는 과정에서 옵티마이저가 추가될 수도 있고요.

우선 첫 번째는 이런 스트링을 토큰으로 만들어주는 렉서입니다.

보시면 이런 스트링은 제가 색상 강조를 하기는 했지만 실제로는 그냥 하나의 스트링이고요. 

이 스트링이 렉서를 통하게 되면 필요없는 부분들은 지워지고 

AST, 이거는 네임이고 이거는 같은 괄호하니까 오퍼레이터, 

그리고 나머지 두 개는 스트링 값이라고 표현되죠.

그래서 필요한 부분만을 가져오는 것을 토근화 하는 것을 렉서라고 합니다.

우선 렉서를 작성하려면 이제 그 언어에서 먼저 사용할 키워드가 있어야 되죠.

그래서 키워드를 우선 정의를 하고요. 

어떤 식으로 정해도 되는데 

해당 예제는 파이썬 공식 도큐먼트에서 렉서 혹은 스캐너를 만드는 방법에 대한 예제입니다.

저도 이런 식으로 키워드를 정의하고 

그리고 정말 보고 싶지 않은 그런 표현이지만 정규표현식을 저에게 활용을 했는데요.

이것 말고도 렉서나 파서는 사실 제너레이터들이 좀 있습니다.

그래서 각각 문법들을 정의하고 이런 문법들을 하나로 합친 후에 

이 부분을 보시면 제너레이터로 일반적으로 구현합니다.

그래서 필요할 때마다 하나씩 꺼내와서 

다음 토크는 뭐고 다음 토크는 뭐고 다음 토크는 뭐고 이런 식으로 확인을 할 수 있게 작성을 하죠.

그래서 이 부분에서는 이제 기초적인 에러를 낼 수 있기는 합니다.

하지만 좀 더 복잡한 에러 같은 건 뒤에서 나오고요.

또 토큰아이로 해서만 할 수 있는 한 가지 특징적인 것은 

현재 이 토큰이 이 소스코드의 몇 번째 줄, 몇 번째 칸에 위치했는지, 

이 정보를 보통 렉서에서 저장을 합니다.

그래서 다음 단계에서 에러가 발생했을 때 

어디에서 문제가 발생했는지를 알릴 수 있게 활용을 하는데요. 

여기는 해당 내용은 없습니다.

제가 거인이라고 표현하는 것들이 있는데 

뉴턴이 거인의 어깨 위에서 세상을 보라고 했죠.

그런 것처럼 우리가 활용하기 좋은 라이브러리들이 몇 개 있는데요. 

우선 소스코드도 몇 개 있습니다.

제가 앞서 보여드렸던 소스코드는 

파이썬 공식 도큐먼트의 소스코드를 출력시킨 건데 

공식 도큐먼트에서도 토크나이저를 작성하는 법이라고 문서가 되어 있고요. 

실제로 제가 처음에 많이 참고했었습니다.

두 번째로는 조금 더 문법이 적은 것은 제이썬 라이브러리에 스캐너에 정의가 되어 있고요.

이런 것 말고도 많이 들어보셨을 넥, 와이에이씨씨, 같은 것도 있고요.

플라이 같은 경우에는 다른 데에서도 활용하고 있는 것입니다.

마지막으로 파이썬 스탠다드 라이브러리에 토크나이저가 있습니다.

이게 실행한 모습인데요. 

위에 보이시는 이런 헬로우파이를 이렇게 작성하고 토크나이저를 정말 실행해보면 

다음과 같은 방식으로 토큰들이 딱 나옵니다.

그래서 제가 처음에는 렉서를 처음부터 짤 생각으로 

해당 소스코드를 많이 참고해서 작성을 했는데요.

이 파이썬 토크나이저 같은 경우에는 파이썬에 새로운 문법이 추가되면 여기에도 당연히 추가되고 

이런 식으로 매우 호환성이 높아서 

혹시 파이썬으로 렉서를 만드시거나 혹은 파이썬을 렉서로 만들고 싶으면 

한번 참고해보시면 되게 많은 도움이 되실 것이라고 생각하고 있습니다.

두 번째는 파서입니다. 

파서는 앞서 보이신 이런 토큰들을 가지고 우리가 문법정보를 담은 트리구조를 생성하는데요.

이것을 구문분석 트리 혹은 AST라고 합니다.

여기서 주의해야 될 점이 하나 있는데요.

AST는 토큰은 원본 소스코드와 순서가 크게 다르지 않습니다. 

그런데 AST는 필요에 따라서 순서가 조금 뒤바뀔 수도 있는데요. 

대표적인 경우로 사칙연산을 들 수 있습니다. 

저 같은 경우는 왼쪽을 먼저 순회하는 트리를 만들었는데 

토큰에서는 A가 먼저 나오고 +가 그다음, b, c가 나오지만 

AST에서는 사칙연산에 우선되어야 하죠.

그래서 곱하기가 먼저 나오고 그다음에는 c가 나오는 식으로 되어 있습니다. 

그래서 파이썬은 이거는 실제 AST 모듈을 출력한 건데요.

실제 어사인 같은 경우에는 변수 할당한다는 AST 노드이고 

어디에 할당한 것인지를 정하고 어떤 것을 할당할 것인지를 

각각 노드로 가지고 있는 이런 AST를 만듭니다.

한번 그래서 간단하게 파서를 작성해보면요.

우선은 앞에서 작성한 렉서를 불러옵니다.

그 렉서에 당연히 소스코드도 집어넣어줘야겠죠.

그리고 이제 이렇게 제너레이터를 한번 하면 첫 번째 토큰에 들어가게 되겠죠.

그래서 이 토큰을 타입별로 여러 규칙들을 나누고 

우선 이름이 네임인데 def 함수 선언하는 키워드가 있다면 몇 가지 경우가 나올 수 있습니다.

함수를 선언했으니까 함수이름이 나와야겠죠. 

그런데 그게 아니라 넘버나 오퍼레이터가 나온다거나 규칙에 맞지 않으면 에러를 발생시키게 해주고 

그 다음에 규칙에 따라서 적합한 노드를 하나 불러오고 그 노드에 맞는 값들을 집어넣어주면 됩니다.

여기서 주의하실 것은 아까 전에 말했던 사칙연산이 가장 주의해야 될 점이기는 한데요.

해당 부분은 제가 저번 학기에 들었는데 폴란드 표기법을 작성하는 방법을 한번 보시면 

그 답에 대한 힌트를 얻으실 수 있을 거라고 생각합니다.

마지막으로 구현할 것은 코드제너레이터인데요. 

이 AST를 순회하면서 우리가 원하는 목적코드를 만들어내는 데 사용합니다.

이제 다음과 같은 AST가 있다고 하면 

우선은 왼쪽부터 순회하니까 왼쪽을 가봤는데 

또 다시 노드를 만났으니 한 번 더 순회를 해야겠죠.

그리고 b를 만나고 c를 만나서 b랑 c가 노드가 되었는데 

두 개를 곱해야 하니까 곱하는 어셈블리를 만들고 

그 값을 저장하고 오른쪽으로 다시 순회해서 a를 불러와서 

이런 방식으로 어셈블리를 만들어내는 타겟 코드제너레이터를 만들 수 있고요.

같은 방법으로 타입은 스트링이고 밸류는 이스 트리이고 하니까 

이렇게 되는 C++코드를 작성할 수도 있습니다.

그래서 코드제너레이터를 먼저 구현하는 첫 번째 길은 노드를 순회하는 노드비지터를 만들어야 합니다.

노드는 이제 보통 저 같은 경우에는 왼쪽을 순회하고 

그 다음에 오른쪽을 순회하는 방식으로 되어 있어서 우선 이쪽 방향을 순회하고 

그 다음에 이쪽 방향 다시 오른쪽 방향으로 순회하는 식으로 되어 있는데요.

문제는 노드의 종류에 따라서 해당 바디가 다를 수 있습니다.

대표적으로 펑션 노드를 들고 싶은데 펑션 노드는 파이썬의 함수에 관한 정보를 담은 노드입니다.

그래서 자기가 가지고 있는 노드는 함수 이름을 가지고 있고 

함수 파라미터들을 가지고 있고 

그 다음에 함수 자기 자신의 바디블록을 리스트로 가지고 있는데요.

이렇게 이게 되게 파이썬 AST 노드들의 일부분입니다.

그런데 얘네들을 타입을 다 일일이 검사해서 

적합한 AST로 보내줘야 되는데 이게 굉장히 검사를 하면 귀찮잖아요.

그런데 파이썬이 다이나믹 언어라서 좋은 점은 

이런 식으로 비지트 다음에 노드 클래스 이름을 가져와서 

해당 클래스 이름을 실행하게 만들어주면 

이렇게 아래 부분에 함수를 구현하기만 하면 이 함수가 실행되는 것을 보실 수 있을 겁니다.

또 이렇게 노드 비지터가 만들어졌다면 

저렇게 비지트넘, 비지트리턴 같이 해당 노드를 만났을 때 실행되어야 하는 함수에 

어떤 것들을 실행해야 되는지를 정의를 해야 되는데요. 

뭐 대표적으로는 심볼테이블, 혹은 클래스심볼테이블을 예로 들 수 있습니다. 

예를 들어서 저 같은 경우에는 딕셔너리로 구현을 했는데요.

심볼테이블은 해당 함수, 혹은 클래스에서 어떤 변수들이 있나, 

그리고 그 변수들의 정보를 담은 것들입니다.

그래서 처음에 아무것도 코드를 작성하지 않으면 타겟코드도 비어있고 

아직 우리는 해당 소스코드에 어떤 변수가 있는지 모르니까 심볼테이블은 비워져 있겠죠.

그런데 이것처럼 푸에 발을 할당하는 코드를 만났을 때 심볼테이블에는 푸가 들어오게 되고요.

그런데 좀 더 나중에 구현에는 조금 달라지기는 했는데요. 

타입 정보 및 해당 변수의 포인트 로케이션 등등을 담는 정보를 담았습니다.

그리고 코드 제너레이터는 앞서 설명드린 것처럼 

이제 해당 AST를 잘 보고 적합한 코드를 생성하게 만들었었는데요.

이 상황에서 네임 아이디는 a라는 이 노드는 a를 호출하는 AST거든요.

그런데 심볼테이블에 a가 없는데 a를 호출하려고 하면 이곳에서 이제 문법에러를 내줄 수 있죠.

이런 식으로 활용하기 위해서 저희는 심볼테이블도 만들어줘야 합니다.

그런데 문제가 하나 있습니다.

이런 네이티브 컴파일러는 어셈블리 혹은 실행파일을 만들어야 하잖아요.

그런데 어셈블리 코드제너레이터를 만들면 신경써야 할 점이 많습니다.

첫 번째 메모리와 레지스터입니다.

사실 현대의 프로그래머들은 주로 메모리만 신경을 쓰고 있습니다. 

신경쓰지 않는 경우도 있죠. 

그러나 여전히 메모리가 어떻게 관리되고 있는지 구조를 이해하는 것은 도움이 되죠.

그런데 대부분의 경우에 그냥 완전히 잊어버려도 되는 게 하나 있는데 바로 레지스터입니다.

레지스터는 CPU 계산하는 곳과 저장장치 중간에 있는 애인데요. 

CPU는 굉장히 빠른데 저장장치는 느립니다.

그래서 종종 연산결과를 레지스터에 캐시를 해서 사용하는 게 효율이 좋습니다.

그래서 써야 하는데 레지스터는 램보다도 저장공간이 적습니다.

그럼에도 불구하고 여기서 레지스터를 사용할 일은 정말 없는데요. 

그 이유는 컴파일러가 적합한 레지스터를 선택해주기 때문입니다.

그래서 이게 언제 추가된 건지 기억이 안 나는데 예전 C++를 보시면 레지스터라는 키워드가 있습니다. 

현재도 있기는 있는데 대부분은 무시한다고 합니다.

그러니까 컴파일러의 발전이 언어에 영향을 미친 굉장히 좋은 사례 중의 하나거든요.

그래서 레지스터는 더 이상 사용자들이 신경써야 될 지점을 넘어섰습니다.

그런데 우리는 컴파일러를 만들어야죠. 

그래서 우리는 레지스터를 신경써줘야 합니다.

두 번째 이제 제가 사실 거의 신경을 쓰지 않았지만 옵티마이징입니다.

우선 이런 간단한 옵티마이징을, 

사실 이건 컴파일러가 꼭 해줘야 되는 일은 아니지만 대부분은 당연히 해줘야 하죠.

그런데 이런 4로 나누는 것보다 2로 쉬프트연산을 하는 게 더 빠르기 때문에 

그렇게 해준다거나 4로 나누고 3를 곱하는 것보다 4분의 1를 빼는 게 더 빠르기 때문에 이런 연산을 해준다거나.

혹은 딕셔너리 같은 경우에는 이쪽 코드가 더 빠르니까 이걸 써준다든가.

이런 쉬운 연산들도 있는 반면 어셈블리에 관해서는 컴퓨터 아키텍쳐를 이해하고 있어야 

좋은 코드가 나오는 경우가 많습니다.

예를 들어서 파이프라인에 있는 하자들을 들고 싶은데요.

현대 CPU들은 대부분 파이프라인으로 작동하죠.

그런데 보시면 이 두 코드는 동치입니다. 

그럼에도 불구하고 이쪽은 하자드라고 하는 값이 정리되지 않았는데 미리 읽으려는 문제가 발생할 수 있고 

아래쪽은 그런 문제가 발생하지 않습니다. 

물론 이 하자드의 경우에는 포워딩으로 해결할 수도 있지만 다른 것도 많거든요.

그래서 컴퓨터 아키텍쳐를 잘 아느냐 모르느냐에 따라서 

같은 역할을 하는 어셈블리라고 하더라도 소스코드 실행은 꽤 성능차이가 날 수 있습니다.

이래서 인텔 컴파일러가 비쌈에도 불구하고 여러 기업들이 채택하는 이유 중의 하나겠죠.

그래서 이러한 이유로 컴파일러를 컴퓨터 과학의 소우주라고 합니다.

그런데 이렇게 어렵다면 어려운데도 불구하고 

왜 이렇게 많은 컴파일된 언어들이 있을까요? 그들이 그냥 괴물이라서 그럴까요?

혹은 우리가 활용할 만한 다른 좋은 방법은 없을까요?

현대적인 프로그래밍 언어 몇 개를 소개해드리고 싶습니다.

이것들이 있는데요.

이들의 공통점이 몇 가지 있는데 당연히 컴퓨터언어라는 공통점이 있을 거고 

두 번째는 전부 다 네이티브 컴파일러를 지원합니다. 

마지막 공통점은 이들은 모두 LMBM를 활용합니다.

제가 컴파일러 세 단계를 렉서, 파서, 코드 제너레이터로 들었잖아요.

그거를 다른 식의 여러 가지 정의가 있겠지만 

또 다른 정의는 프론트엔드, 미들엔드, 백엔드로 들 수 있습니다.

미들엔드는 이 AST를 최적화해주는 것이고 

백엔드는 해당 AST를 읽고 우리가 원하는 타겟코드를 나오는 것을 백엔드라고 하는데요.

이 과정에서 넘겨주는 아까 전에 AST뿐만 아니라 중간언어도 넘길 수 있다고 했잖아요. 

이 중간언어로만 만들어주면 즉 프론트엔드만 만들어주면 옵티마이징 같은 미들웨어, 

각각 아키텍쳐에 맞는 어셈블리를 모두 만들어주겠다는 프로젝트입니다.

그래서 프론트엔드만 작성하게 되면 우리는 이제 모든 컴파일러 전체 버전을 얻을 수 있죠.

그런데 그러면 어떤 언어를 넘겨야 하냐 하면 LLVM IR이라는 것을 넘겨야 합니다.

보시면 오른쪽이 C코드이고 두 번째는 LLVM IR 코드입니다.

보시면 C언어랑 비슷한 것을 보실 수 있죠.

스트럭쳐가 있고 함수도 비슷하죠.

그런데 조금 다른 게 하나 있다면 여기는 점프테이블이 하나 있고 if문이 사라지고 여기 있다. 

어셈블리 언어에서 보셨던 값을 확인하고 0일 경우에는 

이쪽으로 점프하고 아닐 경우에는 이쪽으로 점프하는 명령어가 있죠.

그래서 C언어랑 어셈블리 언어를 적절히 섞은 듯한 느낌의 언어입니다.

이 LLVM IR이 가진 장점은 기본적으로 레지스터가 무한대라고 가정하고 코딩을 합니다.

그래서 레지스터가 컴파일러를 작성하는 사람의 손의 관리에서 벗어납니다.

우리는 그래서 더 이상 레지스터에 관해서 신경을 쓰지 않고 코딩을 해도 되고요.

해당 부분은 자동적으로 적합한 부분을 찾아줍니다.

두 번째는 구조화가 지원되는 점인데요.

특히 스트럭쳐 같은 경우에는 OOP 프로그래밍을 할 때 매우 중요한 요소입니다.

그리고 LLVM이 C언어 및 C++ 컴파일러로 시작되어서 그들의 함수를 호출하는 게 굉장히 쉽습니다.

우선 스트럭쳐 타입에 대해서는 꼭 언급하고 싶은데요. 

이건 사실 리스트랑 굉장히 흡사합니다. 

다만 각각 원소들의 크기가 얘는 각자의 자료에 맞는 크기만큼 벌려져있는데요.

C언어나 러스트 같은 경우에는 결과물들을 보면 

사실 데이터를 가지고 있는 부분과 함수 부분으로 나누어져서 OOP가 구성되는 것을 확인할 수 있습니다.

그리고 파이썬이나 오브젝트C 같은 경우에는 보시면 

사실 클래스매쏘드를 스트럭쳐에 직접 저장하고 있는 형태도 있고요.

어떤 식으로든 우리가 OOP를 구현하고 싶으면 스트럭쳐는 피해갈 수 없는 것입니다.

그런데 사실 어셈블리로도 할 수 있지만 문법상으로 지원하는 LLVM-IR를 활용한다면 훨씬 더 쉽게 할 수 있는데요.

이런 LLVM-IR를 좀 더 파이써닉하게 작성할 수 있는 방법은 없을까요?

파이썬의 역사상 많은 시도들이 있었는데 최근 잘 나가고 있는 프로젝트는 넘바입니다. 

넘바는 LLVM를 활용한 프로젝트인데요.

아나콘다에서 개발 및 관리를 하고 있습니다.

보시면 jit라는 함수를 하고 이렇게 해주면 이게 jit IR로 만들어지고 최적화를 해주는데요.

그 과정에서 활용하기 위해서 만들어진 라이브러리가 이것입니다.

그래서 이 LLVM 라이트라는 라이브러리를 사용할 수 있습니다. 

보시면 이런 식으로 파이썬으로 LLVM IR를 작성하시면 이 모듈에 다음과 같은 LLVM IR 코드가 나옵니다.

그래서 얻을 수 있고요.

게다가 더 좋은 점은 작성뿐만 아니라 

LLVM IR는 어셈블리로 바꿔주고 옵티마이즈해주고 실행하는 과정도 다 지원합니다.

그래서 해당파일을 어떤 엔진으로 굴릴지 어떤 아키텍쳐로 굴릴지 엔진을 하나 만들고 

컴파일러에서 실행을 하고 다음과 같이 만들어주면 

이런 방법으로 해당 모듈을 불러와서 함수 이름을 부르고 

C타입스를 활용해서 다음과 같은 테스트를 진행할 수 있습니다.

그래서 파이썬만을 이용해서 코드를 만들고 실행하고 어셈블리를 얻고 

심지어 테스트까지 다 할 수 있는 좋은 라이브러리입니다.

그래서 제가 만든 이무기는 LLVM 파이썬 프론트앤드이고 파이썬으로 작성되었습니다.

다음과 같은 코드 제너레이터를 가지고 있고요.

처음에는 저는 파서와 렉서를 작성을 거의 많이 했었습니다.

그래서 파서와 렉서 레벨에서 이 기능을 지금 지원하지 않으니까 

에러를 내고 했는데 중간쯤 가다가 

그냥 빨리 결과를 보고 싶은 생각이 강해졌고 

또 최대한 빨리 괜찮은 컴파일을 하나 만들면 

자기 자신을 컴파일할 수 있는 걸 빨리 할 수 있겠다는 생각이 들어서 

중간에 코드제너레이터를 그냥 AST 모드로 활용해서 만들었습니다.

보시면 예를 들어서 펑션데프라는 노드를 만났을 때 

이게 가지고 있는 아규먼트들을 가지고 오고 함수 이름을 매핑 시키고 

이렇게 함수 자료를 만들고 함수 바디를 만드는 작성을 했는데요.

조금 더 자세한 코드는 이렇게 작성이 되어 있고 

그냥 맨 처음에는 메인 함수로 전사를 한다든가 아직 클래스 구현을 마무리 짓지는 않았습니다.

이런 식으로 해서 여기 보시면 함수 바디를 만났을 때 실행하는 거예요.

그래서 아까 전에 구현했던 비지트 함수 있죠.

그게 함수로 넘기면 자동적으로 적합한 IR를 만나서 실행이 되고 

넘버를 만났을 때는 이 값을 넘겨준다든가 이런 식으로 작동하게 하였습니다.

이런 LLVM IR 및 LLVM라이트 레퍼런스들은 저는 이런 문서들을 참고했고요.

이 중에서 가장 추천드리고 싶은 것은 파일러스코프라는 프로젝트이고요.

이 프로젝트를 통해서 저는 LLVM라이트의 사용법을 배웠고 

또 OOP 같은 좀 더 깊은 개념들은 도큐먼트나 매핑 하이레벨 컨스트럭트 투 LLVM IR이라는 도큐먼트를 참고해서 만들었습니다.

굉장히 정리가 잘 된 도큐먼트라 컴파일러를 구현해보고 싶으시다면 

굳이 LLVM를 안 쓰더라도 참고하기 좋은 문서입니다.

그래서 이게 실제로 제가 처음으로 파이썬 코드를 네이티브 코드로 변환해본 결과인데요. 

보시면 이런 파이썬 함수를 이런 LLVM IR로 만들었고 이런 것은 LLVM를 통해서 다음과 같은 어셈블리로 만들어져 있습니다. 

다음과 같이 구성이 되어 있고요.

사실 만드는 과정마다 제 개인적인 역량의 한계를 꽤 느꼈는데요. 

대표적인 한계로는 이제 타입을 반드시 지정해줘야 한다든가 이런 게 있습니다. 

그리고 C파이썬과의 차이를 보실 수 있을 텐데 지금 보시면 프리미티브 타입이죠.

32에 대응되게 되어 있는데 이런 것에 대한 고민도 있습니다.

그래서 제가 이런 컴파일러를 만들면서 배웠던 점은요. 

우선 제가 컴파일러를 처음 만들 때 이런 고민들을 했습니다. 

파이썬으로 파이썬 컴파일러를 만들면 프리미티브 타입을 써도 되나?

혹은 C파이썬에 CAPI를 모두 지원해줘야 되나? 등등 이런 고민들이 있었는데.

우선 이것 말고 제가 한계를 느꼈던 점은 에러 핸들링 같은 것을 만나면서 

아, 공부를 더 해야겠구나 라는 생각도 많이 들었습니다.

사실 에러 핸들링을 하는 가장 쉬운 방법은 GOTO를 쓰는 겁니다.

C파이썬을 보면 실제로 많이 쓰고 있는데 

사실 이 방법은 별로 좋아하지 않아서 제로코스트 익셉션 핸들링을 하는 여러 방법들을 보고 있었는데 

여기서 좀 공부가 필요하겠다고 많이 느꼈고요.

그리고 가장 크게 느낀 점은 파이썬은 다이나믹 언어라는 점입니다.

이런 다이나믹 언어를 사실 저도 굉장히 좋아하는 점인데요. 

아까 전에 노드 비지터를 만들 때 그냥 넘겨버리면 되니까 참 좋다고 생각했는데 

저는 사실 이 코드를 보고 이게 파이썬 컴파일러를 만들면 

파이썬에 이런 문법도 있어? 이런 게 돼? 라는 것을 한번씩 시도를 해봐야 되잖아요.

그래서 이걸 한번 시도를 해봤는데 잘 되더라고요.

먼저 테스트 클래스를 하나 만들고 똑같은 이름의 테스트 클래스 정의를 하나 또 만들었는데 

그러면 저는 여기서 에러가 나지 않을까 기대했는데 

에러가 안 나고 푸랑 바는 서로 다른 게 돼서 잘 실행되더라고요.

여기까지만 해도 넘어갈만 하다 싶었는데 

두 번째로 조금 잠깐 잊고 있었던 문법이 하나 있었는데 

바로 매쏘드 추가 및 변수 추가였습니다.

이게 되게 프로토타입 혹은 이런 언어들에서 느꼈던 충격을 오랜만에 느껴봤는데요. 

클래스를 하나 만들고 클래스의 인스턴스를 만들어봤습니다.

푸에는 현재 바라는 게 없으니까 에러가 나게 되죠.

그리고 새로 인스턴스를 만들고 이번에는 새로운 바라는 걸 추가했습니다. 

그러면 이 바라는 애가 있으니까 에러가 안 나게 되죠.

그래서 여기까지만 해도 괜찮았는데 

그런데 이번에 한번 저 A라는 클래스에 새로운 변수를 추가하게 되면 

이 순간 모든 인스턴스들이 해당 변수를 가져올 수 있습니다. 

그래서 이 순간 바뀌어야 하는 것 때문에 

게다가 내가 정리한 클래스가 아니라 라이브러리의 클래스들도 다 가능하잖아요.

그래서 이거를 구현하려면 

저는 처음에는 C++처럼 클래스 정리가 런타임에 보존되지 않고 모든 걸 점프와 스틱하게 처리하고 싶었는데 

결론은 이와 같은 이유 때문에 런타임 혹은 메타클래스가 있어야겠다는 생각이 들었습니다.

그래서 제가 최근에 가장 시도해보려고 노력하고 있는 거는 이런 파이썬을 컴파일된 런타임에 연결해보는 작업입니다.

제가 제일 적합하다고 생각되는 건 오브젝트C 런타임인데요. 

사실 이거는 굉장히 동적인 언어입니다. 

메쏘드 추가도 가능하고요. 

변수 추가도 가능하고 그래서 사실은 네이티브 코드들이 이렇게 있고 

그것들이 런타임에게 문의를 하고 

그 다음에 이런 함수가 있냐고 문의를 하고 

그 함수에 대한 결과도 리턴해주고 

그래서 네이티브 코드들의 모임과 가벼운 런타임의 조합이 컴파일되는 파이썬에는 

굉장히 좋은 것이 아닐까 라는 생각을 하고 

나름 되게 싸니까 코드로 작성을 해보고 있는데 

LLVM 라이트에 아직 링커가 구현이 안 되어 있더라고요. 

그래서 지금까지 삽질을 많이 하고 있습니다.

또 다른 제안은 한번 그러면 저런 파이썬의 동적인 애들을 그냥 무시한 채 

좀 더 딱딱한, 파이파이에 알파이썬과 같이 

완전히 컴파일 시간에 런타임 없이 실행될 수 있는 것을 만들어보는 건 어떨까요? 라는 제안을 드리고 싶고요.

그래서 제 개인적인 궁극적인 꿈은 이러한 알파이썬 같은 언어로 

파이썬 컴파일러 런타임 및 컴파일러를 만들어보는 게 꿈인데 

이 시도를 한번 해보고 있습니다.

마지막으로 이제 파이썬 커뮤니티 분들께 드리고 싶었던 말입니다. 

제가 좋아하는 말 중의 하나인데 존.F.케네디는 미국은 현재 지위를 유지하기 위해서라도 달려야 한다고 했습니다. 

이는 프로그래밍 언어에도 똑같은 말이라고 생각하는데요.

프로그래밍 언어는 현재의 위치를 유지하기 위해서만이라도 빨리 발전해야 합니다.

특히 파이선의 경우에는 저는 더 그렇다고 생각합니다.

이 자료는 작년 파이콘 키노트 자료인데요. 

파이썬은 파이썬을 먹여살릴 수 있는 특별한 플랫폼이 없습니다. 

그렇기 때문에 저는 파이썬의 힘은 커뮤니티에서 나온다고 생각하고 있습니다.

더 다양한 시도가 나왔으면 하는 기대감이 있습니다.

이건 제가 기억하고 있는 일련의 시도들인데요. 

싸이썬 용도가 빠지기는 했는데 사실 보시면 파이썬 커뮤니티는 그동안 굉장히 많은 시도들을 했습니다.

언래든 쉘로우는 구글이 주도했고 피스톤은 드롭박스가 시도했었고 

넘바는 앞에서도 언급했던 넌파에서 시도하고 있고 

그리고 이들은 모두 파이썬 jit를 도입하려는 시도들이었습니다.

현재 파이파이와 넘바를 제외한 제가 말씀드린 프로젝트들은 모두 더 이상 진행되고 있지 않습니다.

피스톤은 C++로 작성되었는데요. 

드롭박스가 작년 1월에 지원을 중단하였고요.

언래든 쉘로우는 훨씬 더 빠르게 중단했고 

파지썬은 사실 공식중단 상태는 아닌데 

애초에 개발자 두 명이 시간을 내서 하는 거라서 속도도 매우 느리고 하기 때문에 

대부분 커뮤니티에서는 사실상 끝난 프로젝트 취급을 하고 있습니다.

그런데 이들이 실패하기만 한 건 아닙니다. 

언래든 쉘로우 같은 경우에는 LLVM에 굉장히 많은 기여를 했고요.

파이파이는 말할 것도 없는 기여를 했습니다.

대표적으로는 파이썬3.5에 새롭게 구현된 딕셔너리 구현을 했죠.

그리고 피스톤은 C++로 꽤 높은 호환성을 유지한 상태에서 속도와 메모리 개선을 둘 다 할 수 있다는 것을 보여주었고요.

파지썬 같은 경우에는 PEP523에 파지썬에 프레임을 평가할 수 있는 API를 제공해주었습니다.

그래서 컴파일러가 들어갈 수 있는 공간을 만들어줬고.

넘바는 말할 것도 없이 LLVM 라이트 같은 여러 다른 파이썬 프로젝트들이 실행할 길들을 열어주었습니다.

제가 이무기를 만들면서 실제로 되게 이름 있는 유명한 프로젝트들도 많이 봤지만 

그냥 재미삼아 파이썬 프로젝트를 구현하려는 죽어버린 프로젝트들이 많이 있었는데 

저는 그들의 코드도 많이 도움이 되었습니다.

그래서 우리가 만약에 실패하더라도 

이런 실행을 해보고 그 결과들을 공유한다면 

언젠가는 그들의 실패를 피해가고 더 좋은 길로 갈 수 있을 거라고 생각합니다.

그래서 이런 과거의 경험들, 거인들 위에 한번 올라서봅시다.

그리고 이왕이면 그 결과를 공유해서 이제 한번 우리가 우리도 거인이 되어보면 

언젠가는 불가능할 것 같은 일도 성공할 수 있지 않을까 생각합니다.

파이썬을 더 빠르고 다양하게 만듭시다.

이상으로 발표를 들어주셔서 감사합니다.
