안녕하세요? 오늘 파이썬으로 구현한 모바일 로봇 지능으로 발표를 맡게 된 하규태입니다.

제 머리가 되게 짧죠.

전문연구요원이라고 해서 대체복무를 하는데 지난 달에 훈련소에 가서 머리가 이 모양입니다.

보기 힘들어 하시더라고요.

일단 저는 간단하게 소개를 해드리자면 로봇을 개발하고 있는 개발자입니다.

저는 로봇을 개발하고 있지만 항상 소프트웨어개발자다 이거를 강조하는 편입니다.

그리고 내용은 뒤에서 아시게 될 거고 그다음에 발표 내용은 다음과 같습니다.

간단한 소개와 아무래도 로봇 관련된 컨퍼런스가 아니라 소프트웨어, 특히 파이썬 관련된 컨퍼런스이기 때문에 로봇 관련 기초 내용을 다루고 다음에 본론으로 Behavior tree로 지금 모델 구성 방법과 확장한 지능 모듈 집합체 구현 방법을 공유할 것입니다.

그래서 일단 인트럭션에는 오늘 발표의 계기에 대해서 먼저 설명을 드릴 텐데 지금 저는 모 회사에서 자유주행물류모델 소프트웨어를 개발하고 있습니다.

이 로봇은 저기에 나와 있는 대로 공항, 호텔, 웨어하우스 같은 데서 자율주행을 통해서 물류 이동을 하고 그렇게 소모되는 노동력을 줄이고 사람이 좀 더 가치있는 일에 집중할 수 있도록 하는 게 제 목표고요.

오늘 발표는 제가 앞에서 모바일로 보시라고 했잖아요.

모바일로 보시라는 거는 뭐 처음에 흔히들 생각하는 모바일 하면 저희 모바일 폰 생각해서 작은 거를 생각할 수 있는데 그게 아니라 이제 이동할 수 있는 보통 저렇게 이 로봇 같은 경우에도 바퀴 2개가 달려 있거든요.

그런 식으로 이동할 수 있는 로봇에 대해서 언급하는 거니까 그런 거에 대해서 이제 오해가 없으셨으면 좋겠습니다.

그래서 이제 오늘 발표는 이런 로봇에서 상위 레벨 소프트웨어를 어떻게 구현하였고 그다음에 이제 소프트웨어 개발자들이 이런 로봇 개발에 어떻게 기여할 수 있는지 그리고 파이썬이 거기서 가지는 가치는 무엇인지?

이런 것에 대해서 이제 발표하도록 하겠습니다.

그래서 이제 또 다른 계기로는 마침 올해의 파이콘의 주제가 다이브 인투 다이버시티더라고요.

그래서 아무래도 파이썬이 로봇 사례에 적용된 경우가 별로 없지 않을까 해서 지원을 했는데 감사하게도 준비위원회에서 기회를 주셔서 발표를 하게 되었습니다.

그리고 간단하게 방금 설명드린 이 로봇이 어떻게 움직이는지에 대해서 일단 영상을 통해서 만나보도록 하겠습니다.

이것은 실제 저희가 시연을 했던 데모 영상이고요.

(띵 하는 소리)

이런 식으로 짐을 싣고 특정한 위치로 가라라고 명령을 하면 이렇게 자율주행을 할 수 있고 이제 특징이라면 물류로봇 같은 경우에 쉽게 생각할 수 있는 게 구축된 인프라 내에서 예를 들어서 마그네틱 선을 따라다닌다든지 이런 경우를 생각할 수 있는데 이 로봇 같은 경우에 처음에 맵을 그리고 난 다음에 자율주행을 통해서 목적지만 주어지면 패스파인딩을 해서 갈 수 있는 자율주행 로봇입니다.

그다음에 시간이 없어서 좀 생략하고 이제 특징적인 거는 이런 IOT 디바이스와 연결해서 이 부분은 로봇이 스스로 서버를 통해서 자동문에 시그널을 보내가지고 문을 열고 나가는 그런 기능들도 있고요.

뭐 그 외에 뒤에서도 보여드리겠지만 엘리베이터를 알아서 탄다든지 하는 그런 추가적인 기능들도 있습니다.

그래서 지금 사람의 도움없이 알아서 문을 열고 그것을 지나가는 그런 모습들도 있고 그 외에는 이제 시간 관계상 생략하도록 하겠습니다.

그래서 그다음에 이제 드리고 싶은 말씀은 이제 여기 우측에 혹시 이 로봇에 대해서 보신 적이 있으신 분 있나요?

(웃음) 

생각보다 몇 분이 계시는데 이제 저것을 그냥 읽으면 코부키잖아요.

이게 모 회사에서 로스라는 미드웨어에 연구형 플랫폼으로 개발한 로봇인데 이것에 대해서 얘기 드리는 거는 제가 소프트웨어 개발을 쭉 하다가, 저 이거 이제 로봇 개발 하기 전에 유니티 개발자였어요.

하다가 문득 갑자기 저거를 통해서 간단한 프로젝트를 할 일이 생겨서 이제 로봇에 입문하게 되었는데 말씀드리는 거는 소프트웨어 개발자가 로봇에 입문하는 게 옛날만큼 어렵지 않다 이런 말씀을 드리고 싶어서 사진을 넣게 되었고요.

일단 로봇 소프트웨어 엔지니어가 뭐냐에 대한 얘기를 하고 싶은데 그거는 시간 관계상 지나가면서 계속 하도록 하겠습니다.

그래서 일단 로봇 개발에 필요한 지식들에 대해서 이제 먼저 설명을 드리자면 일단 로보틱스의 정의, 정의는 여기 보면 이제 기구 엔지니어, 그다음에 전자공학, 그다음에 이제 컴퓨터 사이언스 등이 이제 결합된 융합 학문이다 그렇게 정의가 나와 있는데요.

이제 최근에는 특히 소프트웨어 관련된 게 이제 조명을 받고 있어요.

그 조명을 받는 이유에는 머신러닝과 같은 핫한 트렌드 기술들이 적용될 만한 어떤 좋은 분야이고 그다음에 이제 로봇이 점점 기능이 발달함에 따라서 로봇을 어떻게 효율적으로 관리할 것인가 이런 게 소프트웨어에서 할 수 있는 영역이잖아요.

그러다 보니까 이제 요즘에 특히 로봇 분야에서도 컴퓨터 사이언스, 소프트웨어가 주목받고 있는데 오늘은 로봇을 어떻게 효율적으로 관리하고 동작시킬 것인가?

그런 내용에 대해서 다루려고 합니다.

그래서 이제 기본적인 로봇 시스템 구조에 대해서 설명을 드릴 텐데요.

이제 밑에 단계부터 설명을 드리자면 이 시스템 오버뷰는 기구적인 거.

로봇의 껍데기를 제외하고 나와 있는 거고 맨 밑의 부분은 하드웨어 부분인데 일단 저희 로봇 사례를 들자면 하드웨어에는 싱글보드 컴퓨터라고 여러분 PC처럼 CPU에 램 달려 있고 SSD 달려 있는 컴퓨터가 중앙에 있고 센서와 액츄에이터가 달려 있습니다.

로봇 가장 중요한 컴퍼넌트 중에 센서, 액츄에이터인데 센서는 카메라처럼 로봇이 주변 환경을 읽어들여야 뭘 할 수 있으니까 그게 센서이고 액츄에이터는 저희 로봇 같은 경우 바퀴 2개 있는데 바퀴를 가지고 있어야 이 환경에서 뭔가 일을 할 수기 때문에 그게 액츄에이터고 그거 관련된 펌웨어, 제어 알고리즘이 맨 밑단계에 있고요.

그다음에 그 위에가 읽어보시면 아시겠지만 네비게이션 스틱, 도킹 스테이션을 도킹 하느냐 마느냐 도킹은 로봇도 배터리를 가지고 움직이기 때문에 배터리 충전을 위해서 필요하고 저 맨쪽 위에 있는 로봇 같은 경우 문이 열리고 닫히는데 그런 거 도버 컨트롤 알고리즘에 주행 중에 알려주기 위해서 LED, 사운드 플레이어 등이 달려 있습니다.

이 부분들이 보통 일반인들이 로봇을 생각했을 때 가장 떠올리기 쉬운 부분인데 이제 오늘의 발표 주제는 그 위에 있다는 거를 말씀드리고 싶은 거죠.

그래서 그 위에서 뭔가를 한다라고 하면 사실 감이 잘 안 잡히실 수 있어요.

그래서 그 부분에 대해서 알려드리려고 합니다.

그다음으로는 서비스 로봇 트렌드와 파이썬에 대해서 알려드리려고 하는데요.

과거 로봇 하면 가정용 청소 로봇, 군사 로봇, 산업용으로 쓰이는 로봇 팔 같은 경우에 이제 딱 제한된 공간에서 제한된 일을 잘하는 데에 목적이 있었어요.

그런데 최근에는 그런 로봇 기술들이 발전하면서 이런 코어 기술들을 가지고 어떤 서비스를 전달할 것인가가 중요해짐에 따라서 좀 더 유연하고 빠르게 프로토 타이핑할 수 있고 그다음에 확장 가능하고 사람의 삶에 결국 들어와야 하기 때문에 로봇이, 그런 면에서 여러 가지 시행착오를 겪을 수 있기 때문에 그런 거 개발하는 데 파이썬이 큰 장점들을 가지잖아요.

그래서 파이썬이 로봇 분야에서도 각광 받고 있다 이런 말씀을 드리고 싶습니다.

그래서 이제 방금 말씀드린 것처럼 로봇 개발의 주안점이 핵심 컴포넌트, 모듈을 잘 개발하는 거에서 핵심 기술을 활용한 가치 창출에 있고 성능 최적화는 다 되어 있으니까 그런 거보다는 빠른 프로토타이핑을 해서 어떤 서비스를 제시해줄 것인지 그리고 파이썬 같은 경우는 핵심 모듈들이 C, C++로 구현된 경우가 많은데 이런 것들을 빠르게 조합하고 프로토타이핑 가능한 장점이 있고 특히 서비스 로봇으로 가다 보니까 사용자 인터페이스도 개발을 해야 하는데 파이썬이 이런 데에 장점이 있고 그리고 멀티로봇을 지원을 하기 위한 서버 인터페이스 구현에 파이썬이 용이하기 때문에 로봇에 활용도가 높다는 거죠.

그리고 이제 로봇 오퍼레이싱 시스템에 대해서 설명할 텐데 로스라는 거에 대해서 들어보신 분들이 계신가요?

로스는 꽤 많이 들어보셨네요.

로스에 대해서 간단하게 소개드리면 여기서 1, 2, 3, 4, 5 이렇게 나열된 그런 특징들을 가지고 있는 로보틱스 분야의 미들웨어입니다.

이거에 대해서 자세하게 설명드릴 시간은 없지만 그 중에서 로스는 기본적으로 하나의억 기능을 하나의 프로세스로 담당하도록 하고 여러 개의 프로세스 집합체가 하나의 로봇 시스템을 구성하도록 하는 분산 시스템을 채택하는데 큰 특징입니다.

4번에 있는 프로세스간 메시지 통신이 중요하다고 생각해서 이거에 대해서 잠깐 설명을 드리려고 합니다.

로스는 C++와 파이썬을 지원하고 있고요.

그래서 로스의 프로세스간 메시지 통신 방법에는 로스 토픽, 로스 서비스, 로스 액션이 있는데 로스 토픽 같은 경우에는 1:N의 통신 방법으로 하나의 프로세스가 어떤 데이터를 발행하면 그거를 구독하고 있던 여러 개의 로드들이 동시에 실시간으로 받아 보는 통신 메시지 기법이고요.

이거 같은 경우 로봇의 사례에 접목을 하면 특히 센서에 많이 쓰이고 있어요.

예를 들어서 카메라나 라이더 센서 같은 게 지금 센싱 되는 데이터를 한 번 딱 뿌리면 그거를 필요로 하는 여러 개의 알고리즘이나 모듈들이 동시에 받아가서 쓴다든지 이런 경우에 1:N 커뮤니케이션이기 때문에 많이 사용되고 있고요.

그다음에 토픽 이그잼플을 넣어놓은 거는 이제 로스를 활용하면 이런 식으로 데이터를 퍼블리시하고 크라이브하는 게 간단하게 구현될 수 있다.

잠깐만 살펴보면 이제 로스의 노드를 선언을 하고 그다음에 퍼블리셔를 정의하고요.

그 퍼블리셔는 토픽 네임과 데이터 타입을 선언해줘야 합니다.

그러고 나서 이제 몇 헤르츠로 돌지, 보통 센서 같은 경우는 주기적으로 데이터를 계속 퍼블리시하기 때문에 그 주기를 설정한 뒤에 무한 루프를 돌리고요.

그다음에 그냥 퍼블리시한다, 그래서 이 코드 같은 경우에는 실행을 하면 헬로 파이콘 코리아 2018을 1헤르츠 주기로 퍼블리시하게 됩니다.

간단하게 퍼블리시 구성을 할 수 있고 이그잼플이라는 나는 이 네임으로 스크림을 하고 싶은데 데이터가 들어오면 콜백으로 들어와서 처리를 하자라고 해 주면 이 콜백에서 그거를 받아서 이렇게 출력할 수 있다.

그래서 쉽게 펍섭을 구현할 수 있기 때문에 퍼블리셔 서브를 구현할 수 있기 때문에 여러 개의 프로세스, 각각의 기능을 가지는 여러 개의 프로세스들이 유기적으로 일을 할 수 있도록 구현하는 데 도움이 되게 많이 된다, 로스가.

그런 얘기를 드리고 싶습니다.

그리고 이제 로스 서비스라는 게 있는데 로봇을 구현하다 보면 서버 클라이언트 구조로 각각의 노드들이 일을 해야 할 경우가 많아요.

서브 클라이언트 구조 같은경우는 워낙 많은 분들이 잘 이해하실 거라고 생각하기 때문에 이 정도만 하겠습니다.

그다음에 중요한 게 로스 액션인데 이게 로봇의 물리적인 특성을 되게 잘 드러내는 메시지 통신 방법이라고 생각해요.

이게 예를 들어서 웹 서버 같은 거 구현할 때 비동기로 처리하고 그런 경우가 많긴 하지만 어찌됐건 대다수의 경우에 소프트웨어는 뭐 하나를 해라 하면 응답이 거의 바로바로 떨어지잖아요.

뭐 1, 2초 이렇게만 걸려도 엄청 오래 걸린다고 하는데 사실 로봇 같은 경우에는 예를 들어서 A포인트로 가 이러면 그 A포인트로 가기 위한 물리적인 시간이 항상 존재를 해요.

물리공간에서 움직여야 하는 녀석이기 때문에 그런 게 존재를 하는데 로스액션 같은 경우에는 예를 들어서 하나의 노드가 그런 움직이는 모듈에게 골을 주어져요.

너 A로 가야 해.

그러면 이제 그렇게 일을 시킨 애는 얘가 잘 가고 있는지 궁금할 거 아니에요.

그리고 걔가 A라는 포인트로 가기 위해서는 시간이 걸릴 거고 시간 동안 골을 받은, 주행해야 하는 모듈은 나에게 골을 주어진 모듈에게 지속, 주기적으로 나 잘 가고 있어, 잘 가고 있어, 잘 가고 있어 보고를 하다가 최종적으로 A 포인트에 도달하면 나 도착했어, 혹은 나 도착했는 데 실패했어.

이런 식으로 리젠트를 날려주는 그런 메시지 통신 방법입니다.

여기 보면 캔슬 있다고 헷갈릴 수 있는데 취소도 할 수 있다는 거고 어쨌든 중요한 거는 골이 주어지면 일을 처리하는 녀석이 주기적으로 피드백, 어떻게 돌아가는지 보내주고 있다가 마지막에 결과적으로 리턴을 시키는 그런 통신 방법이 있다.

이게 상당이 많이 쓰여요.

로스를 통해서 로봇 구현을 할 때, 그래서 간단하게 설명을 드렸습니다.

이 부분은 이제 내용이 많은데... 

그렇게 핵심적인 부분이 아니라서 간단하게 설명만 드리자면 로스의 장점에 대해서 이것을 통해서 말씀드리고 싶었어요.

이제 로스 같은 경우에는 일단 오픈 소스이고 그다음에 이런 기본적인, 이게 네비게이션 스택이라고 되어 있는데 이거는 자율주행이라는 소프트웨어 시스템, 혹은 소프트웨어스택을 말하는 거예요.

그런 스택을 구성하는 데 있어서 얘네가 방금 말씀드린 토픽, 서비스, 액션을 통해서 인터페이스를 잘 구현을 해놨고요.

그다음에 저기 보면 글로벌 플레너, 로컬 플래너 이런 게 있는데 이게 네비게이션 스택을 이루는 중요한 모듈입니다.

선택적으로 사용할 수 있게 구현이 되어 있습니다.

만약에 여러분들이 소프트웨어 개발자로써 어떤 로봇을 개발하고 싶으면 주행 관련된 로스 구현된 것들을 사용하고 여러분들이 하고 싶은 거에 집중할 수 있도록 제공을 하고 있고요.

특히 주행 관련해서 글로벌 플래너를 교체하고 싶으면 인터페이스는 놔두고 내부만 바꾸면 쉽게 수행 기능을 개선할 수 있다 그런 점에서 로스가 장점을 가진다는 거를 이거를 통해서 보여드리고 싶었습니다.

그래서 이제 방금 소개해드린 것처럼 로스가 소프트웨어 개발자에게 안겨주는 가치는 소프트웨어 개발자가 로봇이 부분적으로 어떻게 동작하는지 하나하나의 기능에 대해서 다 알지 못하더라도 추상화가 되어 있기 때문에 인터페이스만 있으면 로봇을 쉽게 개발할 수 있다.

로봇 전공을 하지 않고도 제가 참여할 수 있는 이유고요.

파이썬이 왜 로스의 공식언어가 되었는가?

런타임 속도보다 개발 속도가 중요하기 때문에 그런 경우에서 파이썬이 사용되고 있고 외부와의 연결에서도 유리하지만, 특히 중요한 거는 뒤에서 소개해드릴 Behavior tree도 이런 역할이에요.

여러 핵심 기능 모듈들을 이어지는 역할로 파이썬이 사용될 수 있습니다.

그래서 로스라는 오픈 소스 커뮤니티에서도 파이썬을 공식적인 언어로 사용하고 있고요.

그래서 본론으로 들어가서 Behavior tree라는 거를 소개해드리고 이것을 통해서 이제 어떻게 로봇을 움직이게 되었는가를 설명드리도록 하겠습니다.

Behavior tree의 기본 개념은 정의는 저렇게 되어 있어요.

로봇 분야 그다음에 간단한 게임 AI 구현, 제어 시스템에서 FSM이라고 파이나이트 스테이트 머선이라고 학과 수업에서 들어보셨을 텐데 그런 거를 대신해서 자주 사용되는 계획행를 위한 수학적 모델이라고 해서 이러면 이해하기가 힘들죠.

그다음에 밑에도 분기를 설정하는 중간 노드들과 실제로 행동을 취하도록 하는 말단 노드들로 구성된 트리라고 하는데 간단하게 시퀀스는 자식 노드들을 연속적으로 수행하고 셀렉터는 첫 번째 자식 노드부터 수행하기 시작해서 성공하기 시작하면 멈추는 펄백 기능 중간 노드이고 페럴렉은 병렬적으로 수행하는 건데 이렇게 설명드리면 어려우니까 뒤에서 예시가 있는데 이거를 보면서 설명드리도록 하겠습니다.

이거는 블랙보드 같은 경우에는 하나의 디자인 패턴인데 스트럭처드 글로벌 메모리라고 해서 쉽게 생각하시면 로스에서 여러 개의 프로세스들이 하나의 로봇 시스템을 구축한다고 했잖아요.

그런 거를 하는 데 있어서 여러 명이 같이 일을 해요.

그런데 이제 칠판이 여기 하나 있어요.

누가? 자기가 일을 한 결과물들을 적어 놓으면 필요한 애가 가서 읽어보고 이런 결과가 나왔구나 하고 그거를 가지고 일을 하는 거예요.

그런 식으로 생각하시면 돼요.

놓여 있는 칠판을 글로벌 메모리, 누군가는 라이팅, 누군가는 리딩, 그런 디자인 패턴 중의 하나입니다.

Behavior tree에서 뒤에서 사용되는 게 있기 때문에 간단하게 설명을 드렸고요.

Behavior tree, 아까 시퀀스, 셀렉터 말씀을 드렸는데 Behavior tree가 어떻게 동작을 하고 어떤 녀석인지 예시를 통해서 설명드릴거예요.

딱 보시면 지금은 살짝 이해는 안 갈 수 있는데 이거 보시면 아, 이 로봇이 어떻게 움직이겠구나.

이런 게 보이실 거예요.

첫 번째로 시퀀스는 이름이 시퀀스잖아요.

좌측에서부터 자식 노드들을 순차적으로 실행을 할 거예요.

그래서 첫 번째, 워크 투 도어, 도어 앞으로 가라.

그다음에 이제 두 번째는 두 번째 자식 노드는 Behavior, 말단 노드가 아니라 중간 노드인데 저기서 분기를 타게 돼요.

셀렉터는 아까 말씀드린 것처럼 첫 번째 자식 노드부터 수행을 하는데 성공하면 끝나고 만약에 실패하면 다음 자식 노드 실행합니다.

그래서 저기 셀렉터된 이 부분을 보면 이제 처음에 일단 도어로 갔죠.

그다음에 얘를 만났어요.

일단 문을 열기를 시행을 해요.

그다음에 이제 만약에 문을 여는 거를 성공을 하면 해피하게 문을 열고 닫을 텐데 문을 열지 못했으면 넘어가서 문이 잠겼나 하고 열어봐요.

그런데 그거를 실패하면 펄백으로 문을 부셔버린다.

이런 식으로 로봇의 일련의 행동에 관해서 사람이 이해할 수 있는 수준으로 쉽게 표현을 하는 도구이기 때문에 Behavior tree가 FSM 같은 경우는 써보신 분들은 아시겠지만 스테이트가 늘어나면서 그 관계들이 기하급수적으로 늘어나서 나중에 개발자가 그 FSM, 다이어그램 리딩 자체가 어려움이 있는데 Behavior tree는 로봇이 어떻게 행동하는지 상태에 대해서 기술을 하지만 사람이 읽기 좋아서 개발에 쓰이고 있습니다.

이렇게 말씀드리면 별거 아 닌 거 같고 누가 써 할 수 있는데 거기에 공신력을 더하기 위해서 언리얼 엔진에서 Behavior tree를 간단한 AI 구성하는 데 사용되고 있는 예시를 보여드리도록 하겠습니다.

여기서 보면 이게 플레이어가 움직이는 캐릭터고요.

이게 이 Behavior tree로 구성된 AI예요.

글씨 혹시 다 보이시나요?

잘 안 보이시려나?

그래서 일단 설명을 드리면 이제 여기 셀렉터잖아요. 

처음에 있는 애가 셀렉터인데 첫 번째 자식 노드를 실행해 보고 얘가 만약에 조건을 만족 못 시켜서 실패가 난다면 우측으로 갈 거예요.

그다음에 2개의 자식 노드가 모두 실패하면 아무 일도 일어나지 않을 거고요.

그래서 처음에 보면 얘가 움직이는데 얘가 아무것도 안 하고 있어요.

그냥 여기 조건들을 보면 이제 블랙보드에 타깃이 설정되고 그다음에 그 타깃이 100이라는 숫자, 100이라는 거리 안에 충분히 가까울 경우에 레피드 무브 투 그 물체가 있는 곳을 타깃 로케이션으로 해서 빠르게 뛰어간다, 이런 Behavior인데 이해하는 데 크게 어려움이 없으실 거라고 생각이 되는데 타깃이 내 눈에 들어오고 100이라는 거리 안에 있면 걔한테 빠르게 달려간다는 Behavior이고 우측에는 타깃을 놓쳤어요.

내 시야에서 놓치고 그런데 이제 여기 보면 인버스도 되어 있어서 내가 홈 로케이션, 원래 있던 로케이션을 홈 로케이션이라고 하는 거 같은데 홈 로케이션을 잊지 않으면 이쪽으로 돌아가는 Behavior들이에요.

밑에 보면 타깃 로케이션 설정해서 기다렸다 홈 로케이션으로 간다 이런 건데 이런 분기들이 여기서 보면 얘가 이 AI에 가까이 가면 이쪽이 활성화되면서 이 사람의 캐릭터를 따라가기 시작합니다.

따라가다 시야에서 놓치면 따라가고 있던 중이라 타깃 로케이션이 설정되어 있었고 그런데 시야에서는 안 보이고 그런데 지금 홈 로케이션이 아니니까 여기가 활성화되어서 가다 잠시 멈추고 그다음에 2초 동안 여기서 멈춘 뒤에 홈 로케이션, 원래 있던 위치로 돌아가는데 다시 만나서 따라가요.

이런 식으로 AI를 구성할 수 있다는 거를 보여드리는 거고요.

그래서 이게 사람이 구현하고도 이거를 만약에 전체를 그냥 코드로 짜버리면 되게 많은 이프문, 분기문과 그다음에 반복문과 그런 거를 반복하게 되지만 이런 식으로 Behavior tree라는 패턴화된 방식을 이용하면 사람이 이해하기 쉬운 수준에서 구현을 할 수 있다, 그런 거를 말씀드리고 싶고요.

그다음에 이제 간단하게 저희 로봇이 엘리베이터를 타고 내리는 영상에 대해서 보면서 설명을 드리고 싶은데요.

일단 타는 거까지만 보여드릴게요.

이제 2배속으로 해서 조금 빠른데 지금 여기 보면 별표 돼 있는 부분이 지금 활성화 되어 있는 Behavior예요.

그래서 여기 시퀀스에서 엘리베이터를 사용하자 그러면 이제 첫 번째 자식 노드로 가서 일단 엘리베이터가 있는 존으로 이동해라, 지금 존으로 들어왔기 때문에 그 앞에서 얼라인을 해라, 타기 위해서 준비를 하라는 거를.

그다음에 이게 완료가 되면 와이파이를 통해서 엘리베이터를 불러라, 얘가 6층인데 12층으로 가려는 거예요.

그래서 이거는 엘리베이터를 관제하는 서버에 요청을 보냈고요.

그다음에 요청을 보낸 뒤에는 문이 6층에서 열렸는지를 계속 파악하다가 이제 열렸네 그러면 이제 이렇게 엘리베이터를 타는 Behavior에 들어가게 됩니다.

그다음에 이렇게 쭉 타고 난 이후에는 그다음에 이제 이렇게 문이 닫히는 Behavior가 실행이 될 거고요.

시간 관계상 여기까지 보여드리고 여기서 말씀드리고 싶은 거는 지금까지 Behavior라는 게 어떻게 동작하는지는 봤어요.

그런데 그래서 결과적으로 얘가 어떻게 움직이느냐?

그거에 대해서 간단하게 엘리베이터를 타는 거에 대해서 말씀드리자면 독립적인 모듈로 밑에 아까 이 그림 보여드렸었잖아요.

이렇게 중간에 로봇 코어 소프트웨어, 레이어에 엘리베이터를 타는 거에 관한 실질, 기능적으로 구현한 모듈들이 있어요.

그러면 Behavior는 언제 이 모듈이 실행돼야 하는지 그거를 아까 말씀드린 로스 액션이라는 것을 통해서 애를 실행하고 피드백을 받고 리저트가 성공했다고 하면 다음 Behavior를 시행할 수 있도록 한다는 거죠.

Behavior는 그런 식으로 활용되고 있습니다.

그리고 추가적으로 얘는 저희가 파이트리라는 거를 이용하고 있는데 파이트리는 파이썬으로 Behavior tree를 구현해놓은 라이브러리예요.

그래서 이거 같은 경우는 깃톱에 공개되어 있고 이것을 만약에 Behavior tree에 관심이 있으시다 그러면 이거를 한번 보시면 도움이 되실 것 같습니다.

그래서 이제 Behavior tree로 로봇을 간단하게 어떻게 움직일 수 있느냐를 설명드렸고 이제 저희 로봇도 처음에는 이렇게 Behavior tree만을 통해서 움직였었는데, 그 외에 좀 더 확장된 요구들을 반영하려다 보니까 조금씩 발전시키게 됐어요.

그래서 그거에 대한 경험 사례를 짧게 공유하고자 합니다.

그래서 제가 하고 있는 분야, 소프트웨어 레이어를 저는 로봇, 하이레벨 컨트롤 소프트웨어라고 불러요.

그러니까 보통 컨트롤 소프트웨어 이러면 로봇의 핵심적인 기능을 다루는 레이어를 말하는 경우가 많아서 저는 그거보다 고차원적인 레이어에서 얘들을 언제 쓰고 언제 동작시키고 이런 거를 관리한다는 측면에서 하이레벨 컨트롤 소프트웨어라고 명칭을 정했고요.

로봇이 사용자에 맞게 언제 어떻게 어떤 기능을 사용하는지 정의하는 소프트웨어이고 추가적으로 핵심 모듈들이 파악할 수 없는 그런 상황들이 있어요. 

로봇이 움직이다 보니까 그런 주변 상황에 대한 고차원적 인지를 담당하게 됩니다.

그래서 예를 들어서 로봇이 주행 중에 주변에 사람이 많이 있는지, 아니면 로봇 위치 좌표에 여기는 통계적으로 접촉 사고가 많이 났으면 그거를 인지하게 되면 주행 모듈에 여기선좀 천천히 가라, 접촉 사고 날 수 있으니까 아니면 주의해라고 정보를 내려줄 수 있죠.

그다음에 작업 수행 중에 디버깅에서도 크게 활용되는데 어느 단계에서, 어느 핵심 모듈을 호출하다가 아니면 어떤 단계에서 무슨 이유로 작업 수행에 실패했는지를 이제 여기 상위 레벨 소프트웨어에서 다 관제를 하고 있기 때문에 이런 거를 바로바로 파악을 할 수 있습니다.

그리고 이러한 인지를 바탕으로 판단을 내릴 수 있는데요.

아까 말씀드린 것처럼 저런 부가적인 기능들을 명령을 내릴 수 있는 그런 소프트웨어라고 볼 수 있습니다.

그래서 결과적으로는 로봇의 핵심 기능들이 좀 더 똑똑하게, 그리고 사람의 기준에 맞게 움직일 수 있는 도와주는 역할을 하고 있습니다.

그래서 초기에는 그 구현이 Behavior tree, 순수하게 Behavior tree만을 통해서 구현이 돼 있었어요.

그런데 아까 Behavior tree를 보시면 알겠지만 Behavior tree는 이제 블랙보드에 업데이트된 데이터로 근거해서 어떤 행동을 해야 할지 결정하는 애라 판단을 내려서 블랙보드에 데이터에 엽데이트를 해야 하는 지능 모듈들이 필요하게 됐고 그런 거를 Behavior tree에 우겨넣기보다 그런 애들을 독립적으로 확장 가능하게 추가를 하고 Behavior tree는 그런 데이터에 근간을 해서 로직 분기만을 할 수 있도록 만들자.
그렇게 해서 이제 개발을 시작하게 됐고요.

그다음에 사용자의 요구에 맞는 전체 액션 플랜에 관해서 Behavior tree가 초기에는 작업 착수 시에 A, B, C 갔다가 엘리베이터 갔다가 도킹해라 뭐 이런 일련의 과정들이 잡이 주어지면 한 번에 생성하고 그대로 수행을 하다 보니까 이렇게 막…

아이고.

이렇게 막 큰 Behavior가 생성이 되었거든요.

그렇게 되다 보니까 사실 작업 수행 중에 들어오는 수정 요구 사항 있잖아요.

A, B, C로 가라고 했는데 B 말고 D로 가.

그러면 이런 경우에 B로 가는 서브 트리를 찾아서 그거를 자르고 거기에다가 C로 가는 서브트리를 넣는 불필요하고 복잡한 작업들을 하게 해야 해서 그런 어려움이 있었고 그다음에 결정적으로 Behavior tree가 개발자한테 시각적으로 로봇은 이런 Behavior를 취할거야라고 보여주는 역할을 하는 건데 이렇게 Behavior tree가 방대해지면 개발자가 읽기에도 쉽지 않아요.

그런 면에서 문제가 있었다.

그래서 결과적으로 주변 상황에 능동적인 판단을 내리고 사용자의 다양한 요구에 동적으로 대응하는 그런 액션 플래닝을 할 수 있는 지능 모듈 집합체를 만들자는 목적 하에서 프로젝트 CNS라는 그런…

이것을 시작했고요.

CNS 하면 왜 CNS냐? 이렇게 물어보실 수 있는데 저게 센트럴 널버스 시스템, 사람의 중추신경계에서 이름을 땄어요.

생각하는 모듈들이 여러 가지가 있고 사람이 뇌에서 생각하고 중추신경계, 척수 이런 것을 통해서 각 신체 기관에 명령을 내리듯이 생각하는 모듈과 그것을 Behavior tree를 통해서 각각의 사람의 신체에 대응하는 핵심 모듈에 명령을 내리는 메커니즘과 비슷해서 그렇게 이름을 붙였고요.

그래서 발표 시간이 다 끝나가는데 간단하게 소개해드리면 잡 브로커라는 얘는 사용자나 다른 시스템으로부터 얘가 수행되는 잡을 긁어옵니다.

받아오는 인터페이스이고 얘는 잡을 받아 오면 블랙보드에 이렇게 작업을 해야 한다고 큐잉을 하면 잡 스케쥴러는 체크를 하고 있다가 로봇이 이런 작업을 수행할 만한 여건이 되면 잡을 받아서 수행을 하는데 그 수행하는 방식으로 그 잡에 해당되는 Behavior tree를 동적으로 생성을 해가지고 밑에 핵심 모듈들에게 명령을 내리는 그런 구조거든요.

그러면서 이제 여기 파란색로 된 익스텐션 모듈이라고 되어 있는데 추가적으로 새로운 기능을 담당하는 그런 모듈들을 그냥 개발해서 얘가 어떤 일정한 규칙에 따라서 뷸랙보드에 이런 데이터를 업데이트를 하라고 구현을 하면 그런 업데이트된 내용을 바탕으로 Behavior tree가 동작하면서 그런 내용들을 반영할 수 있도록 그런 식으로 구조를 짰습니다.
그래서 얘는 한참 개발 중이라, 좀 더 발전된 내용이 있으면 나중에 공유를 해드릴 수 있을 거 같고요.

일단은 이 정도로 소개를 해드리겠습니다.

그리고 이제 소프트웨어 개발자가 어떻게 로봇 개발에 기여할 수 있는지에 대해서 얘기해드렸는데 그거에 좀 더 더해서 저희 팀에서는 이제 제가 로봇의 가장 끝단에 있고요.

가장 윗끝단에 있고 그 위에는 멀티 로봇 제어를 위해서 서버... 애플리케이션이 있어요.

그래서 거기에서는 사용자가 어떤 잡을 주면 이런 인터페이스를 통해서 사용자가 어떤 잡을 주면 여러 로봇들이 있는데 어떤 로봇이 이 잡을 가장 효율적으로 수행할 것인지 그런 거를 판단해서 하나의 로봇에다 잡을 쥐어주게 되고요.

그런 식으로 동작하면서 좁은 길 같은 경우에는 여러 로봇이 동시에 지나갈 수 없잖아요.

좁은 길들은 다 자원화, 독점 자원화해서 중앙에서 이 자원을 지금 A라는 로봇이 쓰고 있기 때문에 B라는 로봇은 지금 써야 하지만 잠시 기다려라 이런 트래픽 컨트롤이라든지 이런 거를 하는 거를 소프트웨어 개발자들이 하고 있습니다.

얘는 파이썬이 아니라 노드 JS로 개발하고 있긴 한데 오른쪽에는 상황을 나타내는 애플리케이션이고 이거는 설명드리려고 넣은 거고 마무리하도록 하겠습니다.

오늘 발표를 요약하자면 파이썬이 로봇 개발에 가지는 의미, 그리고 로봇 응용 소프트웨어, 상위 제어 소프트웨어의 역할, 그리고 Behavior tree가 어떻게 활용될 수 있고 그리고 잠깐 설명드린 CNS라는 프로젝트의 의의 그리고, 저는 결정적으로 이거를 말씀드리고 싶었어요.

소프트웨어 개발자가 로봇 개발에 어떻게 기여할 수 있느냐?

사실 많은 분들이 그런 생각을 할 수 있거든요.

로봇 하면 장벽이 높을 거 같고 나는 한 번도 안 해봤는데 어떻게 할 수 있느냐?

이거를 제가 오늘 공유해드린 개발 사례를 통해서 저게 로봇을 꼭 잘 알아야 할 수 있는 게 아니구나.

물론 도메인에 대한 지식은 쌓이고 필요는 하지만 그게 꼭 로봇 공학을 전공해야 한다든지 그런 거는 이제 아니다.

그래서 관심 있으시면 얼마든지 손쉽게 뛰어들 수 있다는 거를 말씀드리고 싶었고요.

그리고 특히 로봇개발은 여러분과 같은 소프트웨어 개발자와 사고를 필요로 합니다.

파이썬은 개발의 중추로써 인정을 받고 있고, 그다음에 기존 로봇 개발 방식이 가지는 한계 같은 게 있어요.

보통 로봇 개발 하시는 분들은 하나의 기능에 집중해서 깊게 들어가시다 보니까 그런 면에서 이제 개발의 한계들이 있는데 그런 거는 소프트웨어개발자들이 어떻게 이런 문제를 효율적으로 해결할 수 있고 이런 거에 대해서 고민을 많이 하기 때문에 그런 부분에서 이제 또 기여를 할 수 있고 그다음에 이제 실제로 이런 기능들을 가지고 서비스를 개발하는 것은 저희 애플리케이션 개발자들의 역할이라고 생각을 해요.

그래서 이제 로봇이 결국 이 사람의 생활에 나오기 위해서는 그런 소프트웨어 개발자들이 필요하다, 말씀드리고 싶었습니다.

그래서 마지막으로 다이브 인투 로보틱스.

파이썬으로 구현한 모바일 로봇 지능이 주제이긴 하지만 다양한분들이 로보틱스, 소프트웨어 개발자로 뛰어들 수 있는 작은 계기가 되었으면 하는 바람에서 이 발표를 준비를 했고요.

그다음에 제 연락처는 저기 메일이 있고 그다음에 아직 시작은 못했는데 제가 군대 훈련소 갔다 오느라…

오늘 발표나 제가 개발했던 경험 사례들을 미디움에 일주일에 하나씩은 업데이트를 하려고 합니다.

혹시나 관심이 있으신 분들은 다음 주쯤부터 방문을 해 주시면 감사하겠습니다.

그리고 마지막으로 슬라이드는 따로 없는데 저희가 로봇 회사라서 소프트웨어 개발자들한테 되게 안 유명해요.

그래서 소프트웨어 개발자를 되게 애타게 찾고 있는데 되게 힘들더라고요.

그래서 로봇 개발 오늘 얘기 들어보시고 관심 있으신 분들은 언제든지 저 연락처나 아니면 이 세션 끝나고 자유롭게 찾아와 주시면 제가 감사하게 응대해드리겠습니다.
