https://www.youtube.com/watch?v=NmSeLspQoAA

안녕하세요? 

Deep Dive into Coroutine 발표를 맡게 된 김대희입니다. 

잘 부탁드립니다.

(박수)

이번 세션에서는 코루틴, 특히 파이썬에서는 코루틴이 어떤 식으로 동작하는지 알아보는 시간을 가지도록 하겠습니다.

코루틴, 특히 어싱크하이브모듈을 사용해본 적이 없는 분들은 이해하는 데 어려움이 있으실 수 있습니다.

이 점 참고 부탁드리겠습니다.

그리고 코드가 좀 많이 나옵니다. 

그래서 한번에 이해하기 어려울 수 있으니 

공개된 PPT를 집에 가서 다시 보시면 이해하시는 데 도움이 될 것입니다.

해당 발표의 사용환경입니다.

해당세션에 사용된 코드와 그에 대한 설명은 청중 분들의 이해를 돕기 위해 

큰 흐름을 방해하지 않는 선에서 적절히 수정되었습니다. 

이 점 양해의 말씀 부탁드립니다.

그러면 본격적으로 다이브해보도록 하겠습니다.

그럼 간단한 두 코루틴를 살펴봅시다.

두 코루틴은 첫 줄에서 이런 식으로 문자를 출력합니다. 

그리고 슬립을 걸어주고요. 

슬립 후에는 다시 또 문자를 출력합니다. 

그리고 이벤트 루프를 가져오고요. 

이벤트루프에 두 코루틴을 등록합니다. 

그리고 실행합니다.

한번 실행해보죠.

가장 처음에 출력되는 건 네, 이 코루틴 퍼스트 엔트리 포인트겠죠.

그리고 코루틴은 1초간 슬립을 할 겁니다.

그다음으로는 코루틴2의 퍼스트 엔트리 포인트가 출력이 될 거고요. 

코루틴2는 2초간 슬립을 하게 됩니다.

1초가 지난 후에 코루틴1이 깨어나고 세컨트 엔트리포인트가 출력이 됩니다.

그리고 다시 1초 후 코루틴2가 재개되겠죠.

코루틴들이 어떤 지점에서 재개하고 일시중지하는지 살펴보겠습니다. 

일단 이벤트루프가 진행되는 가장 처음에 스케줄링 테스트를 실행하겠죠.

그리고 그다음 지점, 코루틴1에서 어웨이트 슬립을 만났을 때가 첫 번째 일시중지 시점입니다.

그리고 실행시점이 다시 이벤트루프로 복귀를 하고요. 

이벤트루프에서 다음으로 스케줄이 된 코루틴2를 실행합니다.

그리고 코루틴2에 어웨이트 슬립을 만났을 때 다시 일시중지를 합니다.

그리고 1초 후 코루틴이 실행이 되어야 하는 시점에서 

어웨이트 슬립 다시 시점에서 재개를 합니다.

코루틴1이 종료된 후 스케줄링된 코루틴2를 다시 1초 후에 실행합니다.

지금 이 코드, 이 코드를 이해하는 것이 이번 발표의 목표입니다.

지금 다 바로 이해한 건 아닌가 하고 생각하실 수도 있는데요. 

하지만 코루틴들이 이렇게 스케줄링되고 시행되기 위해서 

뒤에서 어떤 일들이 일어나고 있는지 이해하지 않는 한 이 코드를 완벽하게 이해했다고 할 수 없습니다.

이것을 이해하기 위해서는 첫 번째로 다중진입지점, 즉, 멀티플엔트리포인트가 어떻게 해서 동작이 가능한지, 

두 번째로 이벤트루프가 실제로 이 함수들을 어떻게 스케줄링하는지 알아야 합니다.

그리고 이것들을 알아가는 과정에서 만나게 되는 

파이썬의 내부구조 등에 대해서도 놓치지 않고 알아보도록 하겠습니다.

다중진입지점, 멀티플 엔트리 포인트에 대해서 일단 말씀드리겠습니다.

방금 봤던 코드죠. 

이 코드 되게 많이 쓸 텐데요.

좀 정리를 해봤습니다. 

재개 지점. 엔트리 포인트라고도 할 수 있는데 

이 코루틴들에는 각각 두 개의 진입지점과 한 개의 일시중지 지점들이 있습니다.

보통 어웨이트라고 하면 여기서 일시중지를 할 거라고 생각을 하실 수 있는데요. 

일시정지 될 수 있다 정도로만 생각하시면 될 것 같습니다.

힌트는 주는 것 정도예요.

그 이유는 어웨이트의 동작방식을 이해하게 하면서 설명드리겠습니다.

코루틴 함수가 일시정지되고 다시 재개하는 매커니즘을 이해하려면 

당연하게도 함수가 어떻게 등장하는지 이해해야 합니다.

이를 이해하기 위해서는 프레임 객체가 무엇인지 알아야 하는데요.

프레임 객체는 함수를 실행할 때 필요한 정보들을 담고 있는 객체입니다.

간단한 함수를 한번 작성해보도록 하겠습니다.

단순히 x에 10를 넣고 y에 20을 넣고 더한 값을 출력합니다.

이때 현재 프레임을 얻어봅니다.

그리고 이 함수를 출력하면 30이 실행이 될 거고 프레임객체가 얻어지겠죠.

그러면 이 프레임객체에 무엇이 있는지 한번 살펴보겠습니다.

사실 이 네 가지 속성보다 더 많은 속성들이 프레임객체에 있는데요. 

우리는 이 네 가지 속성만 살펴보도록 하겠습니다.

일단 f_locals라는 속성인데요. 아까 함수 기억나시나요? x에 10, y에 20.

다음으로 볼 속성은 f_back이고요.

우리가 알고 있는 호출스텝, 등등이 이 함수호출로 생성되는 프레임들입니다.

인터프리터 내부에는 각 쓰레드마다 이와 같이 쓰레드스테이트라는 객체가 있습니다. 

이 함수에 현재 실행하고 있는 프레임을 멤버로서 가지고 있고요. 

함수가 이 상태에서 또 호출이 되면 새로운 프레임객체가 만들어지고 

새롭게 생성된 프레임객체의 f백은 자신을 호출한 프레임을 가지게 됩니다.

또 함수노출을 해보면 이런 식으로 또 만들어집니다. 

갱신이 되고. 이것이 여러분이 알고 있는 포스텝입니다.

다음으로 볼 속성은 f-lasti입니다.

이름만 봐서는 감이 안 잡히는데요. 

30입니다. 어떤 값인지 아직도 감이 안 잡히는데요.

좀 전에 봤던 함수죠. 

이 함수 명은 func고 이 함수의 바이트코드는 

이런 식으로 디스 모드를 임포트한 다음에 함수 자체를 넘기면 이런 식으로 생성되는데요.

여기에 보시면 30을 찾을 수 있죠.

즉 이 함수가 가장 최근에 실행한 바이트코드의 인덱스를 의미합니다.

이 함수는 가장 최근에 호출이 되어서 종료되었고 

리턴이 되었기 때문에 가장 마지막에 실행된 거겠죠.

바이트코드를 다루는 부분은 조금 이따가 좀 더 자세하게 다루도록 하겠습니다.

방금 이야기했던 것처럼 가장 최근에 실행한 바이트코드의 인스터럭션이 f-lasti입니다.

다음으로는 f-code입니다.

이 녀석은 코드객체라고 하는 건데요. 

아까 프레임객체가 어떤 함수에 대한 것인지 기억나셨나요?

이 func에 언더바 언더바라는 속성이 있는데요.

이 둘은 같은 코드객체고요.

코드객체는 여러 가지 속성이 있지만 

저희는 네 가지만 알아보도록 하겠습니다.

코드객체의 속성들에 대해 알기 위해서는 일단 바이트코드에 대한 이해가 필요합니다.

이해를 돕기 위해서 간단한 함수를 준비했고요.

첫 번째는 코드라인을 의미합니다. 

x는 10에 보시면 여기 10. 아직 이것들은 잘 모르겠지만 

x가 있고 10이 있는 것을 볼 수 있죠.

y가 20인 경우는 세 번째 줄 y, 20이 있는 걸 확인할 수 있고요.

두 번째 컬러는 바이트코드 인덱스이고 세 번째 코드는 오프코더, 

네 번째는 오퍼렌드, 다섯 번째는 오퍼렌드 벨류입니다.

그러면 이제 해당함수의 코드객체를 살펴볼게요. 

아까 func에 언더바 언더바 속성 기억나시나요?

그 중에 co언더바코드라는 속성이 있습니다.

뭔가 나왔어요. 잘 모르겠어요. 바이트 열들인데요. 

이걸 좀 더 알아보기 쉽게 넣어봤습니다.

그러면 이처럼 각 바이트들을 숫자의 형태로 볼 수 있는데요. 

얘네들이 바로 얘입니다. 

로드콘스트. 그리고 스트로페스트, 0. 이렇게 됩니다.

이게 정말 로드콘스트가 맞나? 스토어페스트가 맞나? 의아해하실 수 있는데요. 

이런 식으로 오피네임을 설정하면 로드컨스트인 것을 확인하실 수 있습니다.

코드객체의 나머지 속성들에 대해서도 좀 알아볼게요. 

co언더바 콘스트는 이 함수에서 사용된 상수들이 있고요. 

그 다음으로 co-varnames가 있고 co 언더바 네임즈가 있어요.

바이트코드가 이제 어떻게 실행되는지 살펴보겠습니다.

이해를 돕기 위해서 앞에 사용하고 있는 간단한 함수 이거를 그대로 사용하겠습니다. 

우리가 지금까지 이야기한 코드객체와 프레임객체의 조합으로 바이트코드가 실행됩니다.

우측에 있는 바이트코드는 실제로 co언더바코드. 

아까 이야기했죠. 바이트열로 되어 있습니다.

못 보던 것이 하나 있는데 벨류스택이라는 것이 있죠. 

벨류스택 또는 데이터스택, 리벨류에이션스택이라고도 불리는데요. 

이것은 바이트코드가 실행될 때 연산을 하기 위한 사용되는 공간입니다.

어떻게 되는지 살펴보죠.

일단 첫 번째 줄에 로드컨스트를 시행합니다. 

이때 연산자는 1이죠. 

피연산자가. 로드컨스트의 피연산자는 이 컨스츠를 참조합니다.

여기 첫 번째 1에 1 인덱스가 가리키는 값인 10을 벨류스택에 로드합니다.

그 다음 스토어페스트인데요. 

이 값을 해당 값을 지역변수에 넣어주는데요. 

이 f로컬에 넣어주는데 피연산자가 0이죠.

이걸 이것을 참고해서 지역변수에 넣어줍니다.

이전에 말씀드렸던 것처럼 f로컬에 지역변수가 들어가는 겁니다.

똑같이 y에 20을 넣기 위해서 컨스트에서 20을 참조해서 올려주고요. 

마찬가지로 y에 20을 넣어주고요.

그리고 이번에는 로드글로벌을 할 텐데요. 

co네임즈, 이제 이것을 참조합니다.

그리고 로드패스트를 이용해서 벨류스택에 올리고요.

벨류스택에 올라가 있는 값들 두 개를 더합니다. 

그리고 그 값들을 다시 밸류스택에 넣어줍니다.

그리고 함수를 호출하는데요. 

이 콜펑션이라는 것, 이 피연산자 1은 이 함수의 파라메터의 개수가 한 개라는 겁니다.

그래서 벨류스택에서 인자로서 한 개를 취합니다. 

그러니까 30이 어딘가에서 출력이 됐겠죠.

그리고 프린트는 명시적인 반환값이 없기 때문에 None를 말합니다.

그런데 해당함수, 이 함수도 반환값이 명시적으로 있지 않기 때문에 None를 반환하기 위해서 올려놓고 

가장 마지막 값을 리턴하고 함수는 종료됩니다.

다시 돌아와서 코드객체의 속성을 정리해볼게요.

컨스트는 상수들이 있고요. 

네임즈는 글로벌변수의 이름들. 브이알네임즈는 지역변수의 이름들.

자, 이제 우리는 바이트코드도 볼 수 있게 됐습니다. 

그럼 처음 나왔던 코루틴의 바이트코드를 살펴볼게요.

어웨이트 슬립을 하는 세 번째 줄을 보시면 일드프롬이라는 게 눈에 띄실 거예요.

네이티브 코루틴 말고 제너레이터 기반 코루틴이죠. 

이걸 살펴보면 얘는 아시겠지만 그냥 일드 프롬이 있겠죠.

사실 일드프롬은 제너레이터 내부에서 또 다른 제너레이터를 사용하기 위해 쓰이는 코드입니다.

결국 내부적으로 샌드를 하게 되죠.

결국 코루틴의 어웨이트는 일드프롬을 통해 이루어진다는 것을 알 수 있습니다. 

그러면 우리는 제너레이터가 어떻게 일시정지 되는지 알아볼게요.

코루틴이 결국은 제너레이터와 비슷한 거의 동일한 방식으로 동작한다는 것을 알게 되었으니까 

제너레이터의 동작방법을 알면 코루틴도 알 수 있을 것 같아요.

간단한 제너레이터를 만들어보고 복습을 해보죠.

객체를 만들고 샌드를 해줍니다. 

그러면 첫 번째 일드까지 진행되죠.

그리고 다음 샌드를 할 때 2를 넣어줍니다. 

그러면 이 자리에 2가 들어가고 이것까지 갔습니다.

그러면 이 제너레이트가 이제 일시정지 됐을 때 어떤 일이 일어나는지 살펴보겠습니다. 

아까 어웨이트가 무조건적으로 일시정지를 의미하는 것은 아니라고 말씀드렸습니다.

이 이유는 결국 어웨이트는 일드프롬을 하는 것이기 때문에 

단순히 서브제너레이터를 시행하는 것과 거의 유사해요.

그래서 코루틴이 일시정지하려면 결국 안쪽에서 일드를 하고 있는 겁니다.

여기 제너레이터가 일드를 했던 것과 같은 거죠.

이따가 슬립함수 내부를 저희가 살펴볼 텐데요. 

그때 한번 확인해보실 수 있습니다.

일단 제너레이터가 일드를 했을 때 어떤 상태인지 한번 알아보죠.

첫 번째 샌드를 하게 되면 첫 번째 일드 지점에서 함수가 중단이 됩니다. 

이건 우리가 이미 알고 있는 거고요.

제너레이터 객체는 gi프레임이라는 속성을 지니고 있습니다.

아까 프레임을 들고 있는 녀석이 또 있었죠. 

쓰레드가. 쓰레드처럼 제너레이터도 프레임을 들고 있습니다.

이건 조회해보면 2입니다. 

이건 왠지 바이트코드인덱스 같은데요. 

한번 맞는지 확인해볼게요.

이 코드객체를 가져와서 op코드 이름을 조회해봅니다. 

그러면 딱 일드밸류까지 진행된 것을 확인할 수 있습니다.

이렇게 어디까지 지금 진행이 됐는지 제너레이터가 프레임을 들고 있음으로서 알 수 있기 때문에 

일시중지한 다음에 재개를 할 수 있는 거예요.

네이티브 코루틴 이렇게 어싱크로 선언된 경우에 cr코드가 들어 있습니다. 

거의 유사하게 생겼죠. 이름만 다르고.

실제로 샌드 구현 내부입니다. 

훨씬 더 긴 코드고 복잡한데 우리가 관심있는 것만 꺼내서 해보겠습니다.

C언어로 되어 있어요.

일단 쓰레드스테이트를 가지고 오고 이 샌드함수의 첫 번째 파라메터가 제너레이터이고요.

이 제너레이터의 gi프레임을 가지고 옵니다.

이 프레임 객체를 가지고 오고요.

그다음에 아규먼트 처리를 해주는데 이게 우리가 알고 있는 샌드 뒤에 이런 애들이에요.

이 아규먼트를 조금 가공을 해준 다음에 넘겨주는데 보이시나요? 

이 f가 아까 말씀드렸던 이 제너레이터의 프레임이 있죠. 

이게 프레임의 밸류스택의 탑이에요. 

그래서 그냥 구겨넣어준 거예요.

그래서 우리가 이런 식으로 2를 넘겨줄 수 있었죠. 

이런 식으로 밸류스택에 값을 구겨넣었기 때문에 넘겨줄 수 있는 거예요.

그다음에 쓰레드스테이트에 현재 실행 중인 프레임을 이제 f백을 줍니다. 

그리고 이 함수를 실행하는데요.

예, 방금 실행됐던 이 함수, 이 함수에 프레임이 넘어가서 실행이 되는데 

이 함수는 프레임을 실행하는 함수입니다. 

실제 우리가 아까 이야기한 바이트코드들이 있죠. 

이게 이 함수 내부에서 실행됩니다.

나중에 인터프리터 공부하실 일이 있으면 이 함수를 꼭 보시기를 추천드립니다.

보시면 여기에서 이제 op코드들을 실행을 하면서 f-lasti가 갱신되는 것을 확인하실 수 있습니다.

그다음에 op코드들이 다 실행이 완료되면 다시 복귀를 하죠. f-back으로.

인터프리스터 내부까지 살펴봤는데요. 

정리를 좀 해보겠습니다.

프레임객체는 함수가 실행될 때 사용됩니다. 

함수가 실행되는 데 필요한 정보들을 담고 있으며 콜스택을 만들고 내부에는 밸류스택이 있습니다. 

지역변수들의 값을 저장하고요. 

마지막으로 실행한 바이트코드의 인덱스가 있습니다.

코루틴은 제너레이터 기반으로 이루어져 있고요. 

그리고 쓰레드처럼 프레임객체를 가지고 있습니다. 

이 프레임객체가 함수를 어디까지 실행하고 있는지 알고 있고 지역변수들의 상태를 저장하고 있기 때문에 

함수를 일시정지하고 다시 재개하는 것이 가능한 것입니다.

네, 프레임객체이고요. 

우리가 방금 봤던 것들입니다.

이 상태에서 함수를 호출하면 이런 식으로 프레임객체가 하나 더 만들어지고 

새로 형성된 프레임객체에 f-back이 이전 프레임을 가리키겠죠. 

이게 콜스텝입니다.

그리고 이런 식으로 프레임이 돌고 있습니다. 

그리고 이와 비슷하게 코루틴도 프레임을 들고 있다는 것을 우리가 확인을 했었습니다.

네, 자동진입지점에 관련된 내용은 여기까지 하고요.

그다음에 이벤트루프에 대해서 알아보겠습니다.

여기 있는 넌프림티브. 즉 선점형 멀티태스킹인데요. 

반대되는 예입니다. 

선점형 멀티태스킹은 대표적으로 쓰레드가 있습니다.

반면에 비선점형은 스위칭이 되는 지점을 명시적으로 지점할 수 있습니다. 

코루틴은 예를 들면 어웨이트죠.

사실 아까 말씀드렸지만 어웨이트가 아니고 어웨이트 내부에 있는 일드입니다.

이 이벤트루트가 비선점형 멀티태스킹을 부여합니다.

처음보았던 코루틴인데요. 

간단히 설명하면 이벤트루프를 얻어오고 스케줄링하고 스케줄링하고 실행합니다.

스위칭된 지점이 이곳이죠.

그러면 슬립 함수 내부부터 바텀업 방식으로 코루틴들이 어떤 식으로 스케줄링이 되는지 확인해보겠습니다.

슬립함수 내부인데요. 

만약에 슬립을 0 이하로 주게 되면 단순히 지금 자신의 실행을 일시중지하겠다는 건데요.

이런 식으로 그냥 프라이빗 함수인 슬립을 어웨이트합니다. 

이거 한번 보도록 할게요. 

단순히 이래요. 아무것도 없어요.

이렇게 되면 이 슬립을 어웨이트한 태스크는 자기 자신을 놓아줍니다. 

이벤트루프한테 자기 자신을 놓아달라고 하고 

그리고 다음 스케줄링 때 다른 잡들을 수행을 합니다.

그리고 딜레이 값이 0보다 큰 경우에는 이런 식으로 퓨쳐객체를 만들어주고요. 

이벤트루프에 해당 딜레이, 이 딜레이 이후에 퓨쳐에 셋 리절트 매쏘드를 만들어달라고 합니다.

이 콜레이터는 이벤트루프에게 이 딜레이 이후에 이 매쏘드를 호출하라고 스케줄링을 하는 겁니다.

그리고 이 퓨쳐를 결국 어웨이트를 시켜주는데요. 

어웨이트는 결국 아까 일드프롬, 샌드를 한다고 말씀드렸죠.

퓨처 내부를 한번 볼게요.

그러면 실제로 샌드를 하게 되면 객체 내부에 언더바언더바 어웨이트를 실행하게 됩니다.

이때 자기 자신을 셀프를 일드하는 것을 알 수 있습니다.

그러면 이 일드 값을 받는 곳이 어디인지 한번 살펴보도록 하겠습니다.

그곳은 바로 태스크객체인데요. 처음에 기억나시죠? 

이 이벤트루프에는 태스크에 언더바스텝이라는 매쏘드가 있는 것입니다.

직접 이렇게 코루틴를 샌드를 한 거예요.

코루틴과 이벤트루프에 관련된 내용들은 이 언더바스텝에 대부분 있습니다. 

꼭 봐보세요. 상당히 깁니다.

코루틴이 이벤트루프에 스케줄링 된다는 것은 이 언더바 스텝 매쏘드가 스케줄링 된다는 것을 의미합니다.

그리고 이것에서 샌드를 하고 이 세션이 나지 않으면 보시면 이 리절트가 None인 경우, 

아까 슬립 제로였을 때 일드만 된 거 기억하시죠?

그리고 이 경우는 다시 이벤트루프에 다시 이 언더바스텝 매쏘드를 다시 스케줄링 해줍니다.

만약 아까처럼 퓨쳐가 일드된 경우도 있었죠. 

퓨처 내부에서 셀프로 일드했죠.

이런 경우에는 이 리절트가 퓨처인데요. 

퓨처 자체에 이 스텝 매쏘드를 콜백으로 등록을 해줍니다.

사실 여기서 퓨처를 하는 게 아니고 어떤 플래그를 체크하는데 

이렇게 이해해도 저희가 이해하는 데 크게 무리가 없을 것 같습니다.

그래서 태스크의 매쏘드인데요. 

이렇게 만들어질 거고 이 언더바 스텝이 이벤트루프의 콜스텝에 의해서 

스케줄링 된 것을 확인하실 수 있습니다.

퓨처 내부를 보면요. 

에드던 콜백인데요. 

콜백스, 이 콜백 리스트에 어펜드를 합니다.

그리고 셋리절트, 퓨쳐가 완료될 때 이 콜백들을 실행을 하는 게 아니라요. 

다시 또 이런 식으로 이벤트루프에 콜순, 이 콜백 함수들을 또 스케줄링 합니다.

직접 실행하지 않아요.

그림으로 한번 좀 더 정리를 해볼게요. 

지금 많이 복잡했거든요. 

그래서 태스크가 이걸 정리를 해볼게요.

처음에는 이 태스크가 만들어지면 테스크에 언더바스텝이 이벤트루프에 콜순에 의해서 스케쥴이 됩니다.

그리고 코루틴을 샌드를 하고요.

해당 코루틴 내부에서 일드됐을 때 값이 슬립 제로였죠.

슬립 제로면 언더바스텝이 다시 한 번 더 이벤트루프에 스케줄링 됩니다.

만약 일드된 값이 퓨쳐면 이 언더바 스텝을 이벤트루프에 스케줄링하는 게 아니라 

퓨쳐의 에드덤콜백에 넣어줍니다.

그리고 추후에 완료가 되어서 값이 세팅되면 해당 콜백들이 이벤트루프에 스케줄링됩니다. 

방금 여기까지 왔습니다.

그럼 이제 이벤트루프를 구현을 해보기 전에 그 구현에 앞서서 

핸들객체에 대한 이야기를 잠깐 하고요.

이 녀석은 함수 자체를 매핑한 녀석입니다. 

보시면 그냥 함수의 인자들을 넘겨옵니다. 

언더바런을 하게 되면 아까 넘겨줬던 함수들을 실행합니다.

그리고 타이머핸들이라는 게 있는데요. 

이 녀석은 자신이 언제 실행하는지를 나타내는 when이라는 게 있어요. 

그래서 시간측정을 하고요.

이건 비교연산자들이 구현되어 있기 때문에 정렬이 가능합니다. 

when이 빠를수록 앞으로 정렬이 돼요.

커스텀이벤트루프를 만들어보겠습니다.

이런 게 있는데요. 

이 녀석으로 시작됩니다.

단순히 만들어주고요. 

타임매쏘드는 현재 시간을 초 단위로 리턴해줍니다.

그리고 캔슬드는 딱히 관심이 없는데 그냥 넣어놨습니다.

이제 진짜 이벤트루프를 구현해볼게요. 

이런 식으로 스케줄드 리스트와 래디 디큐를 들고 있습니다.

스케줄드 리스트는 특정 시간이 되면 실행될 녀석들을 가지고 있게 됩니다.

래디디큐는 수행할 준비가 된 핸들객체들이 오게 됩니다.

콜순은 아까 스케줄링할 때 많이 나왔죠. 

한번 구현해볼게요. 

콜순은 이런 식으로 매쏘드가 오게 되고요. 

매쏘드에 아규먼트들을 넘겨주면 핸들객체로 이 매쏘드와 아규먼트들을 한번 매핑합니다.

그리고 래디, 즉 바로 실행해도 되는 녀석들을 넣어줍니다.

그리고 기억나시죠? 

태스크에 언더바언더바 됐을 때 언더바스텝이 스케줄링 됐었어요.

그리고 콜레이터는 이런 식으로 호출해주고요. 

콜에서는 언제 시행될지 명시적으로 지정해준 겁니다.

그리고 콜엣 내부에서 타이머핸들을 만들어주고요. 

스케줄드 리스트에 힙푸쉬를 합니다. 

힙푸쉬를 했기 때문에 힙 구조의 형태를 갖추게 되고요. 

가장 빠르게 호출하는 타이머핸들이 위치하게 됩니다.

아까 정렬이 가능하다고 말씀드렸죠. 

0초 이상 슬립을 하게 되면 슬립 시간 뒤에 언더바 스텝을 실행하니 

콜레이터 콜엣 이런 것들이 이끌어오겠죠.

이제 우리 런포에버부터 구현을 해볼게요.

단순히 런원스라는 매쏘드를 무한루프를 돌리고 있는 겁니다.

이런 식으로 아까 스케줄드에 타이머핸들이 들어가 있다고 말씀드렸죠.

이 녀석들을 이제 계속해서 래디에 어펜드해줍니다. 

이제 실행이 되어야 하는 시간이 되었다고 하면 넣어주고요.

그리고 래디에 있는 녀석들을 앞에서부터 하나씩 빼서 실행을 해줍니다.

이 언더바 런에서 아까 봤었던 태스크 언더바 스텝 매쏘드도 실행이 되는 거겠죠.

그리고 이제 타이머 핸들이 스케줄드에 여기에 이 스케줄드에 아직 남아있으면, 

남아있고 그런데 딱히 래디에 아무것도 없어요. 

실행을 할 게 없어요.

그러면 루프가 무한루프를 계속 돌겠죠. 

그렇기 때문에 슬립을 걸어줍니다.

슬립이 뭐 1초, 10초, 100초 걸려있어야 된다고 하면 1초만 걸어주겠죠. 

스케줄드 0에 가장 빠르게 시행되어야 하는 녀석이 있으니까요.

이것만 가지고도 우리가 처음에 만들려고 했던 함수를 실행할 수 있는 이벤트루프가 완성이 된 겁니다.

이걸로도 돼요.

그런데 이건 문제점이 있는데요.

만약 타임아웃이 0이 된 상황, 즉 핸들이 아무것도 없는 상황에서는 무한루프입니다.

그래서 CPU를 계속 점유하겠죠. 

그리고 슬립을 엄청나게 길게 주는 상황이 될 수 있어요.

예를 들면 100만 초 슬립이 걸렸어요. 

그러면 해당 이벤트루프가 오랫동안 멈춰있는데 깨울 방법이 매우 제한적이에요.

깨우기가 매우 어렵죠.

우리는 이것을 이 한계를 극복하기 위해서 셀렉터를 도입을 해볼 겁니다.

셀렉터는 운영체제 콜링함수를 호출할 수 있도록 만든 건데요. 

각 운영체제마다 사용하는 콜링이 다르죠.

이 디폴트셀렉터를 사용하면 운영체제에 맞는 셀렉터를 자동으로 가지고 오게 됩니다.

셀렉터가 어떤 식으로 동작하는지 한번 알아보겠습니다.

셀렉터는 파이디스크립터를 감지해주는데요. 

소켓으로 예를 들어볼게요.

셀렉터를 만들고 서버소켓의 파일디스크립터에 리드이벤트를 등록합니다.

그리고 셀렉터를 호출하고 타임아웃을 넌으로 넣어주면 이 라인에서 무한히 블로킹돼요. 기다려요.

그렇지만 CPU를 더 이상 스케줄링하지 않을 거예요.

그리고 다른 쓰레드에서 이렇게 클라이언트 소켓에 샌드를 해줍니다. 

그러면 서버소켓이 뭔가 받겠죠. 

받게 되면 이 리드이벤트가 발생하게 됩니다.

그러면 이때 이 블로킹이 풀리게 되고요. 

서버소켓이 읽을 수 있겠죠.

이런 식으로 셀렉터가 등장합니다.

그러면 이제 셀렉터를 도입을 해볼 건데요. 

이런 식으로 넣어주고, 방금 했던 겁니다. 

이벤트리드를 등록을 해주고요.

아까 봤던 이벤트루프가 오랫동안 슬립상태가 되는 이걸 방지하기 위한 건데요. 

이렇게 콜순쓰레드세이프라는 걸 호출하게 됩니다. 

실제로 이런 매쏘드가 있어요.

그러면 내부적으로 콜순하고 클라이언트소켓에 샌드를 합니다.

그러면 이 서버소켓이 리드이벤트가 발생을 하겠죠.

문제가 있었던 부분이 아래 부분이고요. 

이걸 보면 타임아웃, 만약에 래디, 즉 바로 실행해도 되는 녀석들이 있다면 기다릴 필요가 없겠죠. 

타임아웃을 0으로 둡니다.

래디에 안에 아무것도 없다면 가까운 미래에 실행될 녀석들이 있는 거겠죠.

이 0번 시간만큼 예를 들어서 여기 1초 후에 실행이 되어야 한다고 하면 

타임아웃에 1초가 들어오겠죠.

그리고 셀렉트 해줍니다. 

그러면 아까 말씀드렸던 것처럼 이 자리에서 블로킹이 되고 더 이상 스케줄링하지 않습니다.

그렇지만 아까 말씀드렸던 것처럼 가장 최근의 미래에 실행되어야 할 녀석이 100만 초 이후예요. 

그러면 안 깨어나겠죠.

그렇지만 이렇게 셀렉트함으로서 살펴보면 아까 서버소켓을 이렇게 했죠. 

그러면 클라이언트소켓을 샌드하면 이벤트가 발생합니다. 

그러면 셀렉트가 봉쇄됐던 것들이 깨어나서 넘어가지게 됩니다.

그리고 다음 루프에서 언더바 레디를 자연스럽게 스케줄링을 하겠죠.

지금까지 만들어본 게 간단한 이벤트루프의 직접 동작하는 거 한번 알아볼 거고요.

그 전에 방금 보여드렸던 셀렉터를 통해 파일디스크립터의 이벤트를 감지했는데요.

사실 이것을 일반화시키면 비동기적으로 할 수 있습니다.

이 부분을 직접 여러분께서 구현을 시도해보시면 참 좋을 것 같습니다.

자, 그러면 지금까지 만들어본 이벤트를 실행해보겠습니다.

가장 처음에 만든 간단한 코루틴입니다.

보시면 지금 만들었던 커스텀이벤트 루프고요. 

방금 있었던 것들이 전부 다 구현이 되었습니다.

PPT랑 똑같아요.

그리고 이거를 이 메인에서, 똑같죠? 단순히 커스텀이벤트로 만들었어요. 

간단하게 실행을 해보도록 하겠습니다.

뭐 별 거 없어요. 그냥 1초 후에 나오고, 잘 동작하는 거 확인했고요.

그런데 이제 우리가 말씀드렸던 다른 쓰레드에서 하는 경우에 문제가 될 수 있다고 말씀드렸죠. 

단순히 슬립 모델을 썼을 경우에는.

그래서 다른 쓰레드에서도 한번 해볼 텐데요. 

코루틴1은 처음에 1-1을 출력하고 그다음에 8초 동안 슬립을 하고 1-2를 출력할 겁니다.

코루틴2는 2초 후에 출력을 할 건데요. 

그런데 이 코루틴2를 다른 쓰레드에서 스케줄링 시킬 거예요. 여기서.

그러면 이 어싱크아이, 이것을 통해서 실행을 해야 되는데요. 

내부를 보시면 이 루프에 콜순쓰레드세이프를 합니다. 

표준 스탠다드 라이브러리가 이렇게 되어 있어요.

그래서 이게 좀 방금 어려우실 수도 있는데 이렇게 된 거예요. 

메인쓰레드에서 처음에 코루틴2를 실행하고요. 

그러면 실행하자마자 1-1를 찍고 8초 동안 슬립을 하고 1-2를 출력을 합니다.

그리고 다른 쓰레드에서는 보시면 3초 동안 기다렸다가 코루틴2를 스케줄링 할 거예요.

이때 스케줄링 되고 그리고 코루틴2가 2초 후에 2-1을 찍을 겁니다.

그러면 이거를 실행해보겠습니다. 

1-1이 찍히고 3초 후에 2-1이 찍히고 하는 겁니다.

지금 보시면 아시겠지만 다른 쓰레드에서 이덜 스케줄링을 한 것을 확인하실 수 있었습니다.

네, 아이고... 네 발표는 여기까지고요. 

잘 들어주셔서 감사합니다.