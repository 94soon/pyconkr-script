네, 안녕하세요? 

파이써닉한 코드가 효율적일까? 발표를 준비한 안주은이라고 합니다.

빨리 제 소개를 하면 저는 마이뮤직테이스트에서 엔지니어로 일하고 있습니다.

저는 장고랑 파이썬3 되게 좋아하고요.

저를 성장시켜준 것이라 되게 감사하게 생각하고 있고 그리고 파이콘을 굉장히 사랑합니다.

제가 2년 전에 코딩을 처음 시작할 때 

이 파이콘에 자원봉사로 참여를 했었는데 

그 때 생각했던 게 여기 있는 사람들과 이야기를 할 수 있으면 좋겠다. 

열심히 공부해서 이야기해야지 했던 게 성장의 발판이었어요. 

그 이후로도 아일랜드에서도 파이콘을 가고 하면서 

성장에 많이 기여해주신 것 같아서 

지금 이 자리를 빌려서 감사의 말씀을 드리고 싶습니다.

세션에 들어가기에 앞서서 이 질문을 한번 드려보고 싶어요.

여러분들은 파이썬을 왜 좋아하나요?

각자 대답이 있겠지만 저는 항상 궁금했었어요.

많은 분들이 이렇게 귀한 주말에 파이콘에 나와주시고 

그리고 아일랜드에서 유럽 파이콘을 돌아보니까 그 친구들은 유럽을 계속 돌아다니더라고요.

다른 언어들은 사실 이런 게 잘 없는데 

우리 파이썬만 왜 이런 게 있을까?를 생각했던 게 되게 큰 질문이었습니다.

이 질문에 대한 답은 저한테는 파이썬에 대한 철학 때문이었어요.

2년 전에 비전공자인 제가 코딩을 해보려고 다른 언어의 책들을 찾아봤었는데 

다른 책들은 변수에 대해서 이야기를 하거나 함수에 대해서 이야기를 하는 반면에 

많은 파이썬의 책들은 파이썬의 철학에 대해서 이야기를 많이 하더라고요.

예를 들어서 뭐 심플은 컴플렉스한 것보다 낫다는 등등.

그래서 제가 이걸 한 가지로 줄여보면 제가 생각하는 것은 이거인 것 같아요.

가장 아름다운 하나의 답이 존재한다.

사실 이게 문학에서도 잘 느끼기 힘든 울림인데, 저만 그런가요?

그런데 제가 생각하는 파이썬의 힘은 

파이써니스타분들의 이런 아름다움에 대한 집착 때문이라고 생각합니다. 

저는 그래서 지금까지도 파이썬으로 문제를 풀기 시작하고 

파이써니스타분들이 만들어놓은 코드로 문제를 푸는 것을 굉장히 좋아합니다.

그런데 말입니다. 

사실 제가 파이썬 뭐 좀 모호하더라고요. 

나라마다, 회사마다 다르고.

그래서 내가 이걸 어떻게 써야 될까? 

읽기 좋고 가독성이 좋은 건 알겠는데 제가 자주 쓰는 코드들은 어떤 게 정답일까?  라는 고민이 들었던 적이 있어요.

이 고민에 가장 컸던 것들은 제가 스트링 포매팅을 할 때였는데요.

뭔가 세 개를 다 가독성이 좋다고 아름답다고 하기에는 다 아름답더라고요.

그런데 이제 제가 코드를 보는데 날마다 이거를 다르게 사용하기도 하고 

어떤 날에는 이거 쓰고 어떤 날에는 포맷을 쓰기도 하고 궁금해졌어요.

내가 이 가운데서 하나의 답을 정한다면 어떤 답이 될까 생각을 하다가 

이렇게 간단한 것들, 문법에서 어느 것이 효율적일까를 한번 계산을 해봤어요.

이 세션 자체가 초급 세션인 만큼 이곳에서 인터프리터의 구현, 이런 거를 말하지는 않을 거고요.

제가 어떤 습관을 정할 때, 어떤 기준으로 습관을 정하게 되었나에 대한 사례발표가 어울릴 것 같습니다.

그래서 간단하게 세 가지를 한번 해보려고 해요. 

첫 번째, 측정을 어떻게 했나를 알려드리고 예시를 하고 회고를 해보겠습니다.

저 같은 경우는 이제 일단 CPU 타임 같은 경우에는 c프로파일을 사용했고요. 

여기서는 다른 거 떠나서 콜펑션이 얼마나 걸리냐 이런 거 해봤고요.

두 번째는 메모리유세이지를 해봤고 그걸 설명할 때 dis 모듈을 사용해서 바이트코드를 까봤습니다.

실제 테스트환경은 맥북프로에서 진행하였습니다.

c프로파일 사용하게 되면 펑션을 정의한 다음에 이런 스트링을 넘겨주면 

오른쪽에 나와있는 것과 같이 콜이 얼마나 걸렸고 시간이 얼마나 걸렸는지 

라인마다도 시간이 얼마나 걸렸는지가 나오게 되어 있어요.

그래서 이런 식으로 한번 재봤고요. 

메모리 같은 경우에도 프로파일러를 이용해서 데코레이터를 달아주면 

라인마다 메모리를 얼마나 사용하는지 알 수 있어요.

그래서 이 두 가지로 한번 제가 겪었던 사례들을 공유해보도록 하겠습니다.

첫 번째는 제일 쉬운 것부터 시작을 해볼게요. 

리스트를 만드는 방법들을 세 가지로 만들어봤어요.

하나는 리스트 컴프리핸션, 어팬드, 엑스텐드예요.

제일 파이써닉한 방법은 컴프리핸션인 것 같아요.

실제로 CPU 타임을 보면 리스트 컴프리핸션이 조금 더 빠른 것을 알 수 있어요.

그 이유를 옆을 보면 알 수 있는데요. 

다른 것 같은 경우에는 n번만큼 어펜드나 익스텐드가 불리기 때문에 굉장히 크고요.

컴프리헨션에서는 한번밖에 일어나지 않기 때문에 조금 더 빠릅니다.

그래서 저는 컴프리헨션을 사용하기로 정했습니다.

두 번째로 조금 더 쉽게 해서 머징, 두 개의 딕셔너리를 합칠 때는 어떻게 할까 고민을 해봤어요. 

이런 상황이 저한테는 되게 되게 많았는데 

첫 번째는 포룹으로 할 수도 있겠고 

두 번째는 업데이트매쏘드, 

세 번째는 딕트컴프리핸션도 가능하겠죠.

그리고 마지막 거는 3.6에서 이제 새로 나온 문법인데 이렇게 할 수도 있어요.

그래서 제가 생각하는 파이써닉한 방법은 

업데이트매쏘드랑 키워드아규먼트였는데 그 둘이 월등히 빠른 것으로 나오게 되었어요.

그래서 제일 많이 걸렸던 것의 바이트코드를 한번 까볼게요.

포루프 같은 경우에는 두 개의 머징을 할 때 

루프도 돌아야 되고 로컬 변수도 찾고 하는 행동들을 되게 많이 해요. 

인스트럭셔닝을 많이 부르게 되는데요.

키워드 아규먼트는 딱 이렇게 간단하게 갑니다.

그냥 로컬 변수들을 가지고 오고 저장하고 리턴 하게 된 것이죠.

그래서 저는 그 두 개의 딕셔너리를 합칠 때는 키워드 아규먼트를 사용하기로 마음먹었습니다.

세 번째는 자료구조 이야기를 해보려고 해요. 

내부구조를 알고 있으면 좀 좋은 게 있지 않을까 싶었던 적이 있어요.

그래서 한번 해봤던 게 어떤 컬렉션 중에서 어떤 하나의 아이템을 찾아낼 때는 

어떤 게 제일 빠를까 찾았더니 당연히 셋이 제일 빨랐어요.

그 이유는 셋이 어떻게 구현되어 있는지를 알게 되면 이해가 바로 되실 텐데요.

셋 같은 경우에는 해쉬탭을 사용을 합니다. 

그래서 다른 것들은 어떤 아이템을 찾기 위해서는 

최대 n번만큼의 과정을 거쳐야 하지만 

셋 같은 경우는 어디에 있는지를 찾을 수 있기 때문이죠.

그래서 만약에 유니크한 아이템이 있거나 

아니면 그 아이템들이 되게 많거나 그거를 찾아야 되는 걸 

많은 경우의 수를 많이 콜렉션 라인의 아이템을 찾아야 될 경우 

셋이 조금 더 유리하다고 볼 수 있고 

조금 컬렉션들이 작거나 아이템들이 작거나 아니면 찾는 게 많이 없을 경우는 

리스트나 튜플이 좋을 것 같아요.

왜냐하면 시간과 메모리가 들기 때문이죠.

그래서 제가 제일 관심을 가졌던 것이 지금 스트링 포매팅인데요. 

세 개가 저는 사실 책에서도 이렇게 나와있고 해서 다 예뻐보였어요. 

그래서 성능 측정을 해보니까 백만 번 돌렸을 때 F스트링이 월등히 빨랐어요. 

거의 3배 넘게 차이가 나는데 이거는 조금 더 파봐도 좋지 않을까 생각이 들더라고요.

그래서 F스트링에 관련한 PEP를 한번 찾아봤어요. 

찾아보니까 파이썬에 뭐 a를 집어넣어라 하고 하다가 

제가 꽂혔던 부분은 빨간색 부분인데 f는 상수값이 아닌 하나의 표현식이라는 말이었어요.

이 말이 처음에 들었을 때는 되게 잘 못해서 저는 어떤 말인가 싶어서 바이트코드를 까봤는데요.

까보기 위해서 세 개의 펑션을 만들어봤어요.

첫 번째 펑션은 그냥 변수 두 개를 만든 다음에 리턴하는 것이고 

두 번째 함수는 두 개의 로컬변수를 만든 다음에 f스트링으로 변환해서 던지는 문법이고, 

세 번째 방법은 두 개의 로컬변수를 만든 다음에 포맷으로 던지는 거였어요.

그걸 까기 위해서 디스모드를 사용했고요.

해보니까 그냥 첫 번째 함수와 두 번째 함수는 큰 차이가 없었어요. 

그 차이라고 한다면 포맷 밸류였는데 

심지어 두 개의 로컬변수를 꺼내서 더하는 데까지의 바이트가 똑같았어요.

그 말은 그만큼 되게 오버헤드 없이 동작을 한다는 걸 알 수 있었는데 

포맷 함수의 스트링을 보니까 인스트럭션을 보니까 좀 추가되는 게 있더라고요.

로드 콘스트, 로드 어트리뷰트, 콜 펑션.

그래서 이게 뭘 의미하나 찾아봤더니 콜 펑션은 말그대로 펑션을 콜하는 거고 한데 

결국은 분명히 오버헤드가 크겠죠.

그래서 저는 많은 경우에 f스트링을 쓰겠다고 마음먹었습니다.

세 번째는 이제 마지막은 슬롯인데요. 

저는 슬롯을 좀 처음에는 안 썼었어요. 

왜냐하면 좀 거추장스럽고 뭔가 다이나믹 한 것들을 지원을 못하니까요. 

그리고 제가 그래서 싸이썬의 큰 목표가 슬롯을 사용 안 하고도 

이만큼 빠른 성능을 낼 수 있게 만드는 것이라고 하더라고요.

그래서 한번 그래도 성능차이가 얼마나 나나 궁금해서 

n를 받아서 n개의 똑같은 오브젝트를 만드는 하는 것들을 만들어봤어요.

돌려봤는데 2배 정도의 성능차이가 나더라고요.

물론 뭐 슬롯 같은 경우에는 딕트 매쏘드를 사용하지 않아서 

안에 있는 것들이 정적인 구조라서 조금 더 효율이 있겠지만 이 정도일지는 몰랐거든요.

그래서 언제든지 객체가 되게 많이 인식될 경우에는 

충분히 그럴 수 있는 하나의 매직매쏘드가 아닌가 생각이 들었고 

저도 제가 갖고 있는 문제들에서 이 슬롯 매쏘드를 잘 쓰기로 마음을 먹었습니다.

마지막으로 이제 회고인데요.

제가 생각하기에는 각 문법 사이에서는 성능차이는 존재하는 것 같아요. 

제가 딱히 맞다 틀리다를 이야기할 때, 

그래서 저는 이걸 프로파일링을 해보면서 어떤 게 조금 더 좋은 매쏘드인가를 찾았고요.

그리고 각 문법에는 써야 할 것도 정해져있는 것 같아요. 

그걸 습관을 들여놓으면 좋지 않을까 생각이 들었고 

습관이 될 수 있는 간단한 문법들은 프로파일링을 해보면 좋지 않을까 했습니다.

물론 이걸 해보니까 ROI를 생각을 해야 하기는 하겠더라고요.

그래서 발표는 여기까지고요. 

그리고 마지막으로 이제 조금 빨리 끝난 것 같은데 

저희가 저희 회사에서는 파이써니스타 분들을 정말 고대하면서 기다리고 있습니다.

저희 옆에 있는 사진이 저희 회사에 있는 코기들인데요. 

저희 회사에 오시면 코기 두 마리가 뛰어놀고 있어요. 

그래서 코기들과 같이 재미있게 코딩할 수 있으니까 재미있게 지원해주셨으면 좋겠습니다.

지금까지 제 발표를 들어주셔서 감사합니다.
