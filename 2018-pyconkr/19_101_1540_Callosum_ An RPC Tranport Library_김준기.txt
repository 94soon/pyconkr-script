https://www.youtube.com/watch?v=3V4-9JfQEvg

네, 안녕하세요? 

레블업에서 기술책임을 맡고 있고 코스랩에서 글로벌오픈프론티어로 활동하고 있는 김준기라고 합니다.

이번 세션에서 발표드릴 내용은 Callosum이라고 불리는 것에 대해서 설명드리겠습니다.

제 소개를 드리면 우선 저는 오픈소스 개발을 되게 오랜 기간 진행을 해왔습니다.

그래서 대략 한 10년 정도 됐는데요. 오픈소스 개발에 참여를 한 지가.

그래서 제일 먼저 했던 건 텍스트큐브 프로젝트를 했었습니다.

아마 제 발표를 작년에 보신 분들도 계실 텐데 했던 얘기 또 하는 거지만 

그래도 처음 보신 분들도 있을 것 같아서 설명을 드리는 거고요.

그래서 이 것을 통해서 웹개발에 처음 입문을 했고요. 

그리고 대학원에 진학을 해서는 GPU 기반의 가속 프로그램을 개발했고요.

이것을 통해서 굉장히 로우레벨에서 하드웨어에 기반한 최적화 

이런 것들에 대해서 여러 가지 경험을 해볼 수 있었고 

이것 역시 오픈소스로 경험한 내용을 공개를 했었습니다.

그다음에 이제 대학원을 졸업하고 나서 

회사를 차리면서 만들게 된 것이 백엔드ai를 만들고 있습니다.

이것도 제가 회사를 창업해서 만들고 있는 프로그램이기는 하지만 역시 오픈소스로 개발을 하고 있고요.

이게 해주는 일은 여러분이 보통 머신러닝 같은 걸 돌리려면 GPU 서버들을 많이 쓰잖아요. 

그래서 자기 워크스테이션을 구축하는 경우도 있고 

회사가 크면 전용 서버를 두는 경우도 있는데 

그런 것들을 쉽게 관리할 수 있게 해주고 또 워낙 버전이 많이 바뀌다 보니까 

다들 코드를 짜는 버전이 다른데 충돌없이 돌리고 싶다. 이런 것들.

엊그제도 보니까 페이스북에 누가 질문을 올리셨더라고요. 

내가 쿠다 9.0에 텐서플로 1.0을 깔았는데 

좀 예전 버전을 돌려야 되는데 

다시 깔면 시스템 망가지는 거 아니냐 이런 질문도 올라오거든요.

그런 문제를 저희는 컨테이너 기술을 활용해서 해결을 해주는 그런 프레임워크를 개발을 했고 

그 프레임워크의 이름이 백엔드ai입니다.

이것을 개발하는 과정에서 저희가 기술 스택을 파이썬과 어싱크IO를 선택했고요.

그렇게 한 이유는 API 서버 역할을 하면서 동시에 컨테이너를 모니터링하고 

그러다 보니까 앞단에서는 API리퀘스트를 계속 받아서 처리를 하는데 

그것을 뒤에 있는 컨테이너와 에이전트 서버들로 중계를 해주는 

양방향 소켓통신이 자주 일어나는 특성이 있습니다.

그러다 보니까 이걸 장고 같은 것을 써도 되지만 어싱크IO를 쓰게 되면 

그 웹소켓이나 스트리밍 처리 같은 양방향 통신 같은 것들을 

훨씬 자유롭게 할 수 있다고 생각해서 선택했고요.

또 개인적으로도 제가 앞서 대학원에서 했던 프로젝트를 했을 때 

패킷 제너레이터 서버와 메인서버를 동시에 제어를 하면서 트래픽을 제어하는 실험을 하는 프로그램을 짤 때 

이미 파이썬을 많이 활용을 해봤습니다. 

그래서 경험이 있기도 했고 해서 어싱크IO 기반으로 개발을 하게 되었는데요.

그 과정에서 어싱크 IO가 아무래도 지원이 부족한 부분이 있어요.

그래서 쉽게 활용하게 하기 위한 AIO도커라는 프로젝트를 참여하다가 

처음에는 컨트리뷰션을 하다가 나중에 메인테이너가 된 적도 있었고요.

그리고 AIO툴즈라는 것도 작년에 발표했었는데 

어싱크IO 기반으로 멀티프로세스 서버를 짤 때 

필요한 여러 가지 유틸리티 펑션들 이런 것들을 개발을 진행을 했고 

그 중에 일부는 파이썬3.7에도, 

물론 저 혼자 개발한 건 아니고 비슷한 아이디어를 여러 사람이 제시를 했었는데 

그런 부분이 같이 반영이 되었습니다.

그다음에 할 게 이번에 발표할 이 Callosum이라는 라이브러리고요. 

이거는 뒤에서 왜 갑자기 RPC가 굉장히 오래된 주제이기도 하잖아요. 

네트워크를 개발해보신 분들한테는.

그런데 왜 갑자기 어싱크IO 기반의 새로운 RPC 라이브러리를 만들게 됐는지 설명을 드리도록 하겠습니다. 

그래서 이제 왜 RPC를 또 만들었을까.
여러 가지 이유가 있는데 저희가 백엔드ai를 개발할 때 

아까 말씀드렸지만 매니저라는 서버가 있고 

뒤에 에이전트들이 여러 서버가 있어서 각 에이전트들이 도커 컨테이너를 돌리는 형태입니다.

그러다 보니까 당연히 매니저하고 에이전트가 다른 서버에 존재하게 되고 

매니저가 전달하는 부분이 AIO제로엠큐라는 라이브러리를 사용해서 

RPC형태로 구현이 되어 있습니다. 

그래서 제로엠뷰를 사용한 이유는 

우리가 보통 직접 TCP 레벨에서 프로토콜을 짜게 되면 

TCP라는 건 무한 스트림을 가정하기 때문에 

메시지 단위로 쪼개주고 내가 어디까지 받았고 그런 것을 직접 코딩을 해야 되다 보니까 

그런 부분에 대한 복잡성을 줄이기 위해서 사용하게 되었고.

또 RPC를 사용하는데 기존에 RPC 라이브러리들은 보통 인터페이스 데피니션 랭귀지라는 개념을 사용합니다. 

그래서 어떤 함수들이 정의되어 있고 그 함수의 리턴값은 뭐다 라는 일종의 스키마를 만들어서 

그 스키마를 서버와 클라이언트 양쪽에 모두 인식을 시키고 

이것을 컴파일 해서 코드 제너레이션 하는 케이스도 있고 한데 

그런 식으로 사전정의된 스키마 위에서만 RPC가 동작하는 경우가 많이 있습니다.

대표적으로는 구글에 GRPC라든지 그런 라이브러리들이 그런 형태를 가지고 있습니다. 

저희가 이거를 개발하는 단계에서는 

이게 기능이 하루아침에 바뀌기도 하고 함수 인자가 바뀌기도 하고 새로운 함수가 생기기도 없어지기도 하고 

이런 일이 너무 자주 일어나다 보니까 

스키마로 버전 관리하는 게 힘들어서 RPC를 쓰고는 싶지만 

가벼운 것을 쓰고 싶다 해서 내가 다이나믹하게 코드 바꾸면 바로 돌아가는 

그런 RPC를 쓰고 싶다고 생각해서 찾아본 결과

마침 제로엠큐 위에 RPC 모듈이 있었습니다.

그래서 그 모듈을 활용했는데 이것의 기본적인 생김새는 그거였어요.

그러니까 파이썬의 클래스로 매쏘드를 정의해놓고 데코레이터를 하나 불러주면 

매쏘드들이 자동으로 RPC 함수로 익스포트가 됩니다.

그래서 클라이언트에서는 서버에 대한 아무 정보 없이도 그냥 연결한 다음에 

매쏘드 이름과 인자를 가지고 불러주면 

자동으로 RPC 라이브러리가 타입체크도 해주고 이름 체크도 해주고 이런 식으로 동작하는 형태였어요. 

사용자 입장에서는 되게 간단하죠.

그래서 이걸 잘 쓰고 있었는데 

이제 백엔드ai를 디버깅 하다가 올해 초에 이게 한 3월쯤의 일이었던 걸로 기억을 합니다.

그래서 디버깅을 하다가 뭔가 구현의 문제가 있는 것 같아서 딱 저장소를 열었더니 

갑자기 저장소 이름에 어밴던드라고 떠있는 거예요. 

그래서 어, 이게 뭐지?

그래서 당황을 했고 자초지종을 알아보니까 메인테이너가 없고 

또 그다음에 이 당시에 파이지엠큐라는 다른 대체 제로엠큐 라이브러리가 있습니다.

원래 얘는 어싱크IO 지원을 안 했었는데 

올해 3월인가 4월쯤에 버전이 새로 나오면서 본격지원을 하기 시작했습니다.

그러면서 사람들이 파이지엠큐가 어떻게 보면 본연의 기능이나 API는 훨씬 더 상세하게 구현이 되어 있거든요.

그러다 보니까 이제 굳이 우리 걸 안 써도 되겠네 하고 말하자면 프로젝트를 버린 상태였죠.

그러다 보니까 이 백엔드ai를 구현하는 데 사실 굉장히 핵심적인건데, 

이 통신 프로토콜이. 그러니까 대책이 필요하게 되었고요.

게다가 파이썬3.7로 업그레이드를 해보니까 어싱크라는 함수 이름을 쓰는 거예요.

이게 파이썬3.5에 어싱크하고 웨이트라는 문법이 처음 추가됐는데 

3.5와 3.6 버전에서는 이게 말하자면 예비 API 같은 거라서 

문법 키워드이기는 하지만 함수 이름 같은 걸로 사용하는 걸 허용을 했었습니다.

그런데 3.7 버전에 와서 이제 이거는 완전히 파이썬 문법의 일부다.

그러니까 이걸로 함수 이름이나 클래스 이름을 정의하면 에러를 내겠다고 변경이 되었고 

그에 따라서 더 이상 쓸 수 없는 상황이 되었습니다.

물론 제가 패치를 해서 쓸 수도 있지만 

버려진 라이브러리를 내가 패치를 해서 계속 유지한다는 게 부담되는 상황이었죠.

그리고 그 외에도 기술적으로 또 다양한 이유들이 있었습니다. 

왜 뭐 그럼에도 불구하고 

그럼 그걸 가져다가 고쳐서 쓰거나 하면 되는 거 아니냐고 생각을 할 수도 있는데 

아까 말씀드린 것처럼 

기존에 RPC 라이브러리들은 보통 IDL을 얼마나 잘 만드느냐에 초점을 맞추고 있습니다. 

예를 들면 작년 파이콘에 발표되었던 스포카에서 발표하셨던 

RPC 라이브러리도 파이썬에서 RPC를 쉽게 구현할 수 있게 도와주는 라이브러리인데 

그것 같은 경우도 타입체크를 얼마나 잘 정밀하게 하고 

어떻게 하면 좀 더 쉽게 할 수 있을 것이냐 이런 문제들에 초점을 맞추고 있습니다.

그런데 저희가 필요한 것은 사실 RPC에 IDL의 정밀함보다는 

네트워크 관련 기능들이 훨씬 많이 필요했어요.

대표적으로는 백엔드ai 매니저와 에이전트는 양방향으로 합니다.

그래서 서로 RPC를 합니다.

이것을 하나의 앱스트랙션으로 표현할 수 있으면 좋겠다. 

굳이 두 개의 채널이나 프로토콜을 정의하지 않고. 그런 요구가 있었고요.

그다음에 어싱크IO를 지원하려고 보니까 기존에는 뜯어고쳐야 돼요.

왜냐하면 함수 상황을 다 바꿔줘야 되는데 

그런 것이 기존 RPC 라이브러리에서는 자유롭지 않은 경우가 많았습니다.

그리고 이제 저희 같은 경우는 

이 RPC를 통해서 함수 호출뿐만 아니라 대용량 파일 업로드나 이런 걸 지원할 계획이 있었기 때문에 

스트리밍도 잘 지원이 되었어야 했고요.

또 그 외에도 앞으로 저희가 로드맵으로 가지고 있는 백엔드ai를 

지금은 저희가 클라우드로 서비스를 하는 버전이 있는데 

저희만 서비스하는 게 아니라 

백엔드ai를 가지고 가서 자기 데이터센터와 클라우드에 설치를 했을 때 

서로 모자라는 자원을 당겨쓸 수 있는 기능을 넣으려고 계획하고 있습니다.

그러다 보니까 매니저를 거치지 않고 직접 통신할 수 있는 그런 방법들이 필요한데 

이걸 위해서 여러 개의 TCP 커넥션들을 묶어서 하나의 암호화된 채널로 전송해줄 수 있는 

그런 일종의 커넥션 번들링과 터널링 역할을 하는 프록시 기능이 필요했고요.

또 이게 왜 필요하냐 하면 에이전트 서버들이 대용량 스토리지 서버들로 접근을 합니다.

예를 들면 아마존 같은 경우는 엘라스틱 파일 시스템 같은 게 될 수 있고 

에저 같은 경우도 클라우드 파일이라는 삼바 파티션을 노출해주는 서비스가 있는데 

그런 서비스에 접속을 하려면 

특정 포트로 특정한 프라이빗 네트워크 안에 있는 서버를 특정 포트로 접근을 해야 돼요.

그런 트래픽을 그 클러스터 바깥에 있는 에이전트가 그런 데이터를 접근해야 되는 경우에 

적절한 권한 인증과 함께 접근을 할 수 있는 통로를 열어줘야 되는데 

그런 것을 자연스럽게 구현하기 위해서 

아, 어차피 이 정도의 요구사항이면 

RPC를 기존 걸 가져다 쓰든지 내가 새로 만들든지 비슷한 정도의 노력이 들어가겠구나 하고 

판단을 해서 개발 제안을 하게 되었습니다.

그래서 이제 만들어야 되겠다....

그런데 뭐 만든다고 해서 과연 내가 원하는 물건이 나올 것인가는 다른 문제인데, 

이럴 때 이제 좋은 방법이 있죠.

스스로 데드라인을 설정하면 만들게 되죠.

그래서 파이콘에 프로포절을 냈고 어셉이 됐죠. 

그래서 만들어야겠죠. 

그래서 만들었습니다.

(웃음)

그런데 이제 원래 제가 오늘 발표에서 

백엔드ai를 실제로 적용하고 그 과정에서 어떤 문제가 있었다는 것까지를 발표하는 게 원래 목표였는데 

이제 Callosum의 구현이 아직 100% 완료되지 않아서 

현재 구현된 부분들을 가지고 주로 테크니컬한 부분의 디자인 초이스에 대해서 이야기를 하려고 합니다.

그래서 Callosum이라는 단어가 흔한 단어는 아니잖아요.

그래서 이게 왜 이런 단어를 썼나.

이게 이 제목을 정할 때 고민을 많이 했습니다.

그래서 그냥 뭐 Callosum이라는 게 

저희가 머신러닝이라든지 AI쪽을 다루는 회사이기도 하고 

저희 회사 대표님이 뇌과학을 전공하신 분이기도 하고 

그러다 보니까 뇌 구조물 중에서 뭔가 연결하는 역할을 하는 그런 구조물의 이름을 따오면 어떨까 라는 아이디어에 착안을 하게 되었고요.

그래서 Callosum이라는 것은 한글로 풀어서 이야기하면 뇌교 또는 뇌량이라고 불리는 구조물입니다.

그래서 이게 좌뇌와 우뇌의 대뇌피질에 있는 뉴런들이 

대뇌 안쪽은 사실 신경 뉴런 세포들이 있는 게 아니고 다 신경 다발로 이루어져 있거든요.

그 다발들이 좌뇌와 우뇌 사이를 연결하는 묶음에 해당하는 부분을 Callosum이라고 부릅니다.
그
래서 이게 선천적인 기형이나 아니면 사고를 당하거나 해서 

이 부분에 손상이 되게 되면 좌뇌와 우뇌가 따로 놀게 되거든요.

그러면 예를 들면 내가 양 손으로 옷의 단추를 채우려고 하는데 

한 손은 계속 방해를 하는 거예요. 

그런 현상도 벌어지고.

그리고 또 그런 거를 외계인손증후군이라고도 이야기하고요.

또 간질발작 같은 경우에는 뇌 전체에 신경신호가 과부하가 걸리면서 

갑자기 너무 많은 양의 신경신호가 한꺼번에 발화하면서 생기는 그런 증상인데 

이런 것을 완화하기 위해서 이 뇌량을 일부러 수술로 절제하는 경우도 있다고 합니다.

저도 이 분야 전문가는 아니지만 검색을 해보니 이런 것들에 관련이 있고요.

그래서 이 이름을 제가 잘 붙였다고 생각을 한 이유는 

커넥션번들링이나 터널링을 하기 위해서는 이제 신경다발이 여러 개가 묶여있다는 개념이 잘 맞는다고 생각을 했었고 

또 저희가 이제 머신러닝을 돌려주기 위한 프로그램이다 보니까 

아, 그래. 뇌 좌뇌와 우뇌 반구에서 뭔가 러닝을 하고 이런 연산들을 서로 연결해주는 그런 의미로 

Callosum이라는 이름이 맞는 것 같다고 생각을 해서 이름을 붙이게 되었습니다.

여기에서 이제 제가 한 가지 강조를 하고 싶었던 이유가 

이거는 RPC 라이브러리라기보다는 트랜스포트라는 것을 강조하고 싶었습니다.

그런데 기존에 IDL은 사실 너무 잘 해줘요. 

파이콘에 발표되었던 니름 같은 것도 굉장히 잘 만든 IDL이라고 생각이 되는데 

그러니까 이미 남이 잘 해놓은 거를 제가 또 할 필요는 없겠죠.

그래서 그 부분은 가능하면 기존에 있는 라이브러리들을 재활용할 수 있게 했으면 좋겠다.

그리고 우리는 그러면 밑단에 있는 네트워크 레이어와 그 아래에 있는 IDL 레이어 사이에 들어가서 

그 중간에 내가 원하는 네트워크를 위한 추가기능을 구현했으면 좋겠다.

그리고 장점도 누리면서 이게 저희 백엔드ai도 워낙 프로그램이 복잡해지다 보니까 

우리도 이제는 스키마 기반의 RPC스키마를 가져갈 필요가 있다고 요즘 생각하기 시작했는데 

이런 트랜지션을 자유롭게 할 수 있으면 좋겠다는 생각을 하게 되었고.

또 여러 클러스터 간의 통신을 연결해줘야 하기 때문에 암호화나 인증에 대한 부분도 

이 레이어에서 직접 지원을 해주면 좋겠다는 요구사항을 갖고 출발했습니다. 

그래서 이 구현을 할 때 가장 중점으로 삼았던 이유는 

물론 파이콘이라는 아주 중요한 데드라인도 있었지만 

최소한 돌아가는 것부터 시작을 해서 기능을 붙여나가는 식으로 하자.

그래서 제일 먼저 한 일은 일단 이런 형태의 인터페이스였으면 좋겠다고 생각을 하고 예제 코드부터 짰어요. 

사용하는 예제 코드부터.

아직 라이브러리는 존재하지 않지만

그래서 그 예제코드에 맞춰서 이 시점에 이러한 정보를 넣어서 

이런 부분을 초기화를 하고 이런 식으로 호출하는 API이면 내가 편하게 쓸 수 있지 않을까 라는 

걸로 출발을 해서 개발을 하게 되었습니다.

그래서 실제로 이제 초창기에 만들었던 예제코드고요. 

지금도 그대로 이대로 돌아가고요.

이거는 이제 제이슨을 시리얼레이어로 사용해서 제로엠큐를 기반으로 메시징하는 RPC 구현체입니다.

그래서 클라이언트는 당연히 어디로 접속할지에 대한 정보가 있고 

그래서 시리얼라이저와 디시리얼라이저는 제이슨 기본 모듈을 사용하겠다. 

그 다음에 타임아웃은 이렇게 지정하고 그래서 상대방 연결을 만들고 그 다음에 함수호출을 하고 

에코라는 RPC 펑션을 호출하고 싶고 거기에 인자로는 딕셔너리로 헬로우라는 메시지를 넣어서 보내고 싶다.

그다음에 돌아온 리스펀스를 받아서 출력을 하고 간단히 덧셈하는 함수를 또 호출하고.

이런 아주 직관적이고 간단한 코드입니다.

그래서 보시다시피 당연히 어싱크IO 기반으로 되어 있기 때문에 모두 다 어싱크 어웨이트를 사용하고 있습니다.

이거를 구현해주는 서버의 경우에도 이게 전부예요. 

밑에 이벤트루프를 만들고 하는 부분을 제외하고는 이게 전부인데 RPC 펑션을 정의하고 

일종의 웹 프레임워크들 보시면 이런 경로로 요청이 왔을 때 

이런 핸들러를 시행하라 이런 라우터테이블을 만들잖아요. 

그런 개념으로 핸들펑션을 해서 에코라는 이름으로 들어오는 것은 

이 핸들에코로 처리하라고 해주는 거고 여기서도 마찬가지로 제이슨을 기본 라이브러리로 사용합니다.

여기서 신경썼던 부분 중의 하나는 이 밑에 보시면 커넥션을 대기를 하고 

그 다음에 커넥션을 닫고 이런 부분을 별도의 태스크가 아니라 

그냥 다 하나의 코루틴으로 만들어놨어요.

그래서 이게 하나의 서버의 역할을 하는데 

이렇게 한 이유는 어싱크IO 기반 라이브러리를 만들 때 

그 라이브러리가 내부적으로 암묵적으로 태스크를 스폰하는 경우들이 있어요.

그런데 이게 그 라이브러리가 그 매니지먼트를 잘 해주면 괜찮은데 

가끔 가다 어느 시점에 내가 서버를 종료를 시켜야 할 때 

그 종료할 때 암묵적으로 스폰된 태스크들을 다 찾아서 닫아줘야 하거든요.

그런데 이런 것을 라이브러리에서 제대로 지원을 안 해주는 경우에 굉장히 힘듭니다.

그래서 그러한 매니지먼트는 온전히 이거를 사용하는 사용자에게 맡기겠다는 컨셉으로 

코루틴만 노출을 해주고 내부에서는 암묵적으로 태스크를 만들지 않는 방향으로 그렇게 처리를 했고요.

그런데 이제 이거를 막상 개발을 처음에 API를 설계를 할 때는 그렇게 생각을 했는데 

실제로는 이 핸들러 펑션들은 태스크를 만들어야 합니다.

그래서 그 서버에 메인 루프는 태스크를 쓰지 않아요.

이거는 사용자가 알아서 만들어서 쓰라는 개념인데 

이 안쪽에 들어가는 핸들 함수들은 얘네들은 서로 비동기로 돌아야 하잖아요.

그러니까 여기는 이 함수들이 호출될 때마다 스폰이 되는 그런 구조로 만들어졌습니다.

그리고 이제 지금 만들었던 제이슨으로 그냥 헬로우 다시 보내주고 

덧셈 간단하게 해주는 아주 간단한 RPC 서버인데 

이거를 쓰리푸트라는 RPC 라이브러리가 있는데요. 

그거를 이용하면 전용 인터페이스 언어가 있습니다.

그걸로 심플 서비스라는 걸로 타입과 함수들을 정확하게 선언을 해주고 

이거를 쓰리푸트파이라는 걸로 로드를 해서 스키마를 빌드를 한 다음에 

이 스키마를 Callosum에 어퍼라이브러리 어댑터에서 제공하는 클라이언트 어댑터를 써서 객체를 만들고 

그 어댑터에 함수호출을 넣어서 똑같이 불러주게 되면 

이 부분이 이제 쓰리푸트 프로토컬에 의해서 시리얼라이즈되고 되는 부분을 그대로 활용하면서 

어싱크로 네트워크 요청을 할 수 있게 됩니다.

이게 서버에서도 마찬가지로 이 스키마는 그대로 동일하게 활용을 하는데 

아까와 다르게 서버어댑터를 활용을 하고요.

그리고 이 디스패쳐라는 개념을 이용해서 어싱크 함수로 핸들러 매쏘드들이 붙어있는 클래스를 정의해주고 

서버를 생성할 때 어댑터라는 것을 이용해서 

이 피어객체를 어댑터에 넘겨주고 피어에게 이러한 함수를 핸들링하라고 지정을 하게 되면 

마찬가지로 서버 사이트에서도 그대로 Callosum 위에 얹어서 사용할 수 있게 됩니다.

사실은 제가 원래는 쓰리푸트뿐만 아니라 

니름이라든지 아니면 프로토콜버퍼라든지 이런 것들도 붙이는 것은 퓨처워크로 계획하고 있습니다. 

그러면 Callosum의 내부에 대해서 간단하게 설명드릴게요.

그래서 기본적으로 이것도 레이어 아키텍쳐를 가지고 있습니다. 

제로엠큐 같은 기본 네트워크 트랜스포트 역할을 하는 레이어들이 있고 

그 위에 Callosum이 올라가고 

그 위에 기존의 IDL 역할을 해주는 RPC 라이브러리들이 들어가게 됩니다.

그런데 여기서 조금 다른 부분이 사용자 어플리케이션이 보통은 어퍼레이어 위에 올라가게 되는데 

저희는 어떻게 보면 Callosum에 직접 붙어있다고 보는 게 더 맞는 것 같아요.

그래서 리퀘스트를 보면 예를 들면 이렇게 올라가서 

어퍼 레이어에서 타고 Callosum를 통해서 다시 가고 

여기서 뭔가 핸들러 펑션이 처리가 된 거를 다시 Callosum를 통해서 스케줄링 돼서 

어퍼 레이어를 거쳐서 다시 나가는 이런 구조에 더 가깝다고 볼 수 있겠습니다.

그러다 보니까 이게 이 어퍼레이어를 사실 붙일 때 조금 제한이 있어요. 

그러니까 어퍼레이어 자체가 네트워크 펑션을 다 구현을 해서 

내부에 두고 있는 경우에는 그 부분을 뜯어내야만 붙일 수 있는데 

쓰리푸트를 먼저 붙인 이유는 그게 뜯어내기 쉽게 되어 있어서 그렇고요.

이 중간에 왔다 갔다하는 부분에 여러 가지 기능이 들어가고 

그러니까 어싱크 스케줄러라는 것이 들어가서 

이 핸들러 펑션들이 다 비동기로 실현이 되는데 

걔네들을 어떤 방식으로 스케줄링 할 것에 대한 것을 커스터마이징할 수 있고 

그 다음에 로어레이어로 나가는 부분에서는 인크립션과 그다음에 인증을 지원하게 됩니다.

그래서 여기서 이제 인크립션과 어댄티케이션을 어떻게 했는지, 

어싱크스케줄러를 어떻게 구현했는지 간단히 설명해볼까 합니다.

그래서 이 경우에 제로엠큐를 개발해서 보통 쓰시면 

보통은 그냥 프라이빗 네트워크 안에서 쓰는 프로토콜이라고 생각을 해서 

별다른 인증이나 암호화 같은 것을 걸지 않는 경우가 많습니다.

성능을 위해서 쓰는 라이브러리이다 보니까 더 그런 경향이 있는데 

저희는 아까 이야기한 대로 퍼블릭 네트워크를 타야 되는 트래픽이 있고 

이것을 제로엠큐로 보내려고 하다 보니까 제로엠큐에 어떤 암호화가 가능한지 알아봤어요.

그래서 간단하게는 TCP에 그걸 가지고 올리는 방법이 있는데 

찾아보니까 이미 제로엠큐에서 자체적으로 구현을 해놨습니다.

쉽게 말하면 제로엠큐 버전에 해당하는 그런 개념이고요.

기본적으로 퍼블리티와 프라이비티를 이용한 비대칭 암호 알고리즘입니다.

그래서 그 소켓을 처음 만들 때 내가 어떤 도메인을 쓸 거라는 

서버와 클라이언트가 공유하는 정보가 있고.

그리고 이제 서버에 클라이언트는 서버에 퍼블리티를 알아야 돼요. 

그래서 서버한테 처음 패킷을 보냈을 때 서버가 응답하는 걸 보고 

아, 내가 지금 맞는 서버에 접속했는지 알아야 하고 

클라이언트는 자신의 프라이비티로 서버가 보내온 랜덤 메시지를 암호화를 해서 보내면 

서버는 내가 그 클라이언트를 알고 있느냐.

알고 있으면 인정을 해주고 그런 식의 프로토콜이 있습니다.

그런데 이제 여기서 중요한 것은 

저희가 백엔드ai 입장에서 봤을 때는 

예를 들면 어떤 에이전트가 내 매니저한테 붙었는데 

과연 나한테 붙어도 되는 거냐는 거를 인증할 방법이 필요하고요.

그러기 위해서는 클라이언트들의 퍼블리티 목록을 스스로 관리할 수 있어야 됩니다.

그러면 그 부분을 이 목록을 내가 어떻게 관리를 하고 

서버가 떠있는 동안 그 목록이 계속 변경될 텐데 어떻게 할지 알아보니까 

제로엠큐에 정의가 되어 있어서 

예를 들자면 Callosum에서 피어를 만드는 건 이 소켓을 만드는 건데 

내부적으로 인터널한 IPC 서버를 하나 더 띄웁니다.

그러면 미리 정의되어 있는 이름이 있고

이 인증서버에서 GAP라는 프로토콜을 구현해서 통신을 하게 되면 정의해서 쓸 수 있습니다.

그래서 이 인터페이스를 이용하면 

내가 어떤 도메인으로 접속한 어떤 클라이언트인지를 인증을 해주는 과정을 커스터마이징을 할 수 있습니다. 

그래서 이제 Callosum에서 제공하는 앱스트릭트어덴티케이터 인터페이스가 있고요.

Callosum은 양방향으로 접속을 할 수 있기 때문에 

양쪽 다 구현을 할 수 있게 하나의 클래스로 제공을 하고 있습니다. 

그다음에 어싱크 스케줄러가 있는데 

모든 게 비동기이면 요청이 들어와서 바로 실행하고 끝나면 리턴하고 

이게 어떤 순서로 오버랩이 되든지 그냥 그 시점에 그대로 다 작동이 되겠죠.

그게 이제 오더링을 하지 않는 경우라고 보시면 되겠습니다.

이 그림에서 색깔이 같은 박스들은 같은 요청키, 클라이언트가 임의로 정한 랜덤 문자열이라고 생각을 하시면 되는데 

같은 요청 키로 다른 펑션, 같은 펑션을 부를 수도 있고.

그런데 그냥 다 오버랩이 되는 거죠.

그런데 이것을 스케줄링을 커스터마이징 할 수 있게 개발을 한 게 Callosum의 한 가지 특징입니다.

그래서 이제 아까 말씀드린 것처럼 

서버의 리스닝루프 자체는 태스크화가 되지 않고 

그 부분은 사용자한테 맡긴다고 이야기를 했지만 

개별 핸들러 펑션들은 다 태스크화가 돼서 동시에 비동기로 돌아가게 되는데 

이 부분은 AIO 잡스라는 라이브러리가 있습니다.

이걸 이용하게 되면 내가 현재 시스템에 최대 몇 개의 코루틴이 스폰될 수 있는가를 제안해줄 수 있습니다. 

그래서 만약 너무 리퀘스트가 빨리 들어와서 코루틴이 몇천 몇만 개가 돼서 폭주하는 경우가 생길 수 있는데 

그런 것들을 막아주는 역할을 하고요.

그 라이브러리와 기본적으로 인티그레이션이 되어 있고 

그리고 피어가 양방향 접속이 가능한데 

그것에 따라서 서버 양쪽 서버에 스케줄링 폴리시를 서로 다르게 가져가는 것도 가능합니다.

그래서 두 가지의 오더링 모드를 지원하는데요. 

하나는 함수가 끝났을 때 비동기함수로 같은 리퀘스트 키에 대해서 

비동기 함수들이 계속 다른 시점에 끝날 텐데 

그걸 부른 순서대로 리턴을 해주는 그런 방식의 스킴이 하나가 있고 

두 번째는 완전히 같은 리퀘스트 키에 대해서는 핸들러를 한번에 하나씩만 실행을 하는데 

다른 리퀘스트 키에 대해서는 상관하지 않고 동시에 실행해라, 

이런 두 가지 모드를 지원하고요.

타입2가 왜 필요했냐 하면 

도커 컨테이너를 지원하기 위해서 하는데 이 도커API의 레이턴시가 상당히 큽니다.

컨테이너를 만들고 삭제하는 데 시간이 걸리는데 

이 앞뒤에 컨테이너를 스톱시키고 상태정보를 읽어오고 실제로 지우고, 

이런 일련의 과정들을 매니저에서 다 제어를 하거든요.

그런데 그러다 보니까 이 API 콜에 매니저에서는 부르륵하고 쫙 어싱크콜을 했는데 

클라이언트에서는 아직 스톱이 안 된 상태에서 딜리트를 하려고 하거나 이런 식으로 순서가 꼬일 때가 있습니다.

그러다 보니까 

아, 그러면 내가 이거를 같은 컨테이너 아이디에 대해서는 시리얼라이저를 하고 

다른 컨테이너에 대해서는 비동기로 처리를 할 수 있으면 좋겠다. 이런 구현이 필요해졌고.

그래서 아까 이야기한 리퀘스트키를 컨테이너아이디로 사용을 하게 되면 

그런 컨테이너 제어에 대한 디팬던시 문제를 해결할 수 있습니다.

그다음에 추가로 구현을 하는 부분이 이 부분이 사실 구현이 완전히 다 끝나지 않았어요. 

그래서 그림으로만 보여드리면 여러 개의 리퀘스트가 서로 섞여서 전송될 수 있고 

그 다음에 그 리퀘스트나 리스펀스의 용량이 큰 경우에 적절히 청킹이 된다는 건데 

이건 새로운 개념은 아니고 HTTP2에서 이미 도입한 개념입니다. 

아이디어를 빌려와서 구현을 하고 있습니다.

그래서 이거를 구현을 하면서 여러 가지 어려움이 있었는데 

아까 이야기한 것처럼 

기존에 IDL 라이브러리들이 네트워킹 부분을 커스터마이즈하는 게 워낙 어렵다 보니까 

어떤 경우에 우리가 이 IDL를 쉽게 인티그레이션 할 수 있을지 어려움이 있었고 

정확하게 내가 어떤 것을 제공하면 이게 된다는 것을 정리하는 부분, 이 부분이 어려움이 있었습니다.

그리고 이야기 들은 것처럼 니름도 굉장히 좋은 라이브러리라고 생각되고요.

그 다음에 이제 이게 네트워크 라이브러리다 보니까 당연히 성능을 생각 안 할 수 없는데요. 

파이썬에서 보통 이런 류의 프로그램을 짤 때 가장 오버헤드가 걸리는 부분이 시리얼라이제이션 부분입니다.

그러다 보니까 그걸 어떻게 빨리 할 거냐, 

그리고 파이썬에서는 가능한 파이썬 코드로 하는 걸 사실 가능하면 줄여야 돼요. 

가능하면 라이브러리 안에서, 

C모듈 안에서 되는 것들을 찾는 게 중요하고요.

그러다 보니까 이제 다양한 챌린지들이 등장하는데 

결론적으로 선택한 솔루션은 메시지팩과 스내피라는 구글에서 개발한 고속 스트리밍용 압축 알고리즘을 사용하게 되었습니다.

그 중에서도 왜 굳이 메시지팩을 썼느냐 하는데 조사를 해봤더니 

결론적으로 메시지팩이 제일 훌륭합니다.

이게 상대적으로 파이썬 오브젝트를 덤프를 해서 시리얼라이즈 하는 경우 덤프된 거를 역변환을 하는 경우, 

그 다음에 변환된 오브젝트들의 인코딩된 데이터스트림의 사이즈가 얼마나 작은지. 

낮을수록 좋은 건데 제이슨을 기준으로 했을 때이고요.

그런데 이제 보시면 오른쪽에 성능이 더 좋은 애들이 있는데 

얘네들을 안 쓴 이유는 뭐냐 하면 이거는 파이썬 내부에서 쓰기 위한 겁니다.

그래서 네트워크로 어떤 인풋이 들어왔을 때, 

인풋이 중간에 변조가 됐을 때 그때 시스템이 깨질 수 있는 위험이 있습니다. 

디코딩할 때 그런 쪽에 밸리데이션이 안 되는 경우가 있어서 

그런 의미에서 성능은 좋지만 쓸 수가 없었고 나머지 중에서는 메시지팩이 제일 좋았다는 거고.

그 프로토콜 버퍼같은 걸 쓰지 않은 이유는 

사실 저의 입장에서는 그건 Callosum 위에서 그걸 사용하기를 바란 거였거든요.

Callosum의 네트워크 프로토콜은 어떻게 보면 굉장히 씬 레퍼에 해당하는 거고 

그 안에 들어가는 메이저 프로토콜은 사용자가 선택을 할 수 있게 하겠다는 게 컨셉이었기 때문에 

간단한 수준만 제공하는 직렬화를 사용하게 되었습니다.

그래서 뭐 앞으로는 싸이썬이나 러스트 같은 걸로 더 고속화를 해보고 싶고 

클러스터링이나 AI네트워크라고 저희가 준비하고 있는 프로젝트가 있는데 

이런 걸 이용해서 구현하거나 할 때 활용하려고 계획하고 있습니다.

그래서 이걸 하면서 여러 가지 고민과 생각을 했었는데 

백엔드AI를 통해서 또 하나 새로운 오픈소스 프로젝트를 만들었다는 것이 어떻게 보면 하나의 의의라고 볼 수 있겠고, 

그런데 항상 고민이 되는 거는 비슷한 일을 하는 라이브러리가 많이 있잖아요.

그래서 그러면 내가 직접 만들 거냐, 기존에 있는 것에 기여를 할 거냐, 

아니면 기존에 있는 것을 내가 메인테이너십을 가지고 와서 직접 매니지를 할 거냐.

이 오른쪽에 스샷이 그거예요. 

제가 물어보니까 그 프로젝트 총괄 매니지 하는 분이 있는데 이분이 내가 이거 너한테 선물로 줄 수 있어. 

니가 직접 매니지할 거면. 이래서..

(웃음)

아, 이걸 해야 되나 말아야 되나 고민을 했던 적도 있었고요.

결국은 새로 짜기로 했죠.

그런 것이 있었고 그다음에 아까 이야기했던 대로 처음부터 예제를 만들어놓고 그 예제를 돌아가게 만들고 

그다음에 그 예제의 기능을 하나씩 더하는 방식으로 코딩을 하다 보니까 

실제로 지금 이 슬라이드에 구현이 됐다고 해서 보여드린 부분은 일주일 안에 다 구현이 끝났습니다.

그래서 아, 그런 식으로 구현을 하는 게 말이 되는 어프로치인 것 같다는 생각을 했었고.

문제는 그 다음에 제가 계속 바빠서 더 개선을 못한 게 안타까운 부분이고 

그리고 어떻게 하면 더 인티그레이션을 잘 할 수 있을지는 명확히 도출하는 부분을 고민하고 있는 단계입니다.

여기까지가 제 발표였고요. 

이런 종류의 일을 하는 데 관심이 있으신 분은 저희 회사를 찾아주시면 감사하겠습니다. 

이상입니다.
