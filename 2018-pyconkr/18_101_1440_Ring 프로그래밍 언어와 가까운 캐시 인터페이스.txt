https://www.youtube.com/watch?v=k55l5jn8zsY

안녕하세요? 모두 반갑습니다. 

저는 정윤원이라고 하고요. 

오늘은 Ring이라는 캐시 라이브러리에 대해서 소개하려고 합니다.

오늘 타이틀이 프로그래밍 언어와 가까운 캐시 라이브러리입니다.

시작하기에 앞서서 잠깐 사전조사를 해보려고 하는데요. 

혹시 캐시 프로그래밍 해보신 분 얼마나 되시나요?

아, 감사합니다. 혹시 장고 사용자 분들 얼마나 되시죠? 네, 감사합니다.

그러면 시작하도록 하겠습니다.

간단하게 소개를 드리면요. 

저는 2015 한국 파이콘에서는 PyPI 알파이썬으로 20배 빨라지는 JIT 아희 인터프리터를 했었고 

구름입력기라는 한글입력기를 만들고 있습니다.

오늘의 주제는 Ring은 뭐냐. 이거 왜 쓰냐. 

어떻게 만들어졌냐. 이런 이야기를 할 거고요.

Ring은 이렇게 요약할 수 있는데요. 

관심있는 주제가 있으면 기억해두시면 좋겠습니다.

자, 본론에 들어가기에 앞서서 먼저 캐시에 대해서 잠깐 이야기를 할 건데요.

캐시를 왜 하느냐.

이건 오늘의 주제는 아닙니다. 

캐시를 왜 하는지는 이미 아시는 분들을 위한 시간이고요.

하지만 캐시를 어떻게 하느냐는 이제 링을 왜 하는지와 맞닿아있는 주제입니다.

Ring은 왜 쓰느냐. 

요약하자면 스토리지는 잊어버리고 

코드에 집중하고 인간친화적인 인터페이스를 쓰자고 할 수 있고요.

그러면 캐시는 무엇입니까?

하나의 컨셉이죠. 

어떤 스토리지든 스토리지가 있으면 캐시 스토리지로 쓸 수 있습니다.

그래서 간단한 스토리지가 있다고 할 때 

이렇게 코딩을 하면 캐시 펑션에 대한 캐시를 만들 수 있는데요. 

코드가 번잡해서 여기서 읽을 수가 없죠. 

그래서 제가 표시를 해뒀습니다.

여기서 실행의도가 담긴 코드는 아래 두 부분이고요.

캐시펑션을 실행해서 액츄얼 펑션의 결과가 나오게 되죠.

나머지는 그냥 전부 반복적인 노동입니다. 

캐시 키를 만들고 스토리지 검사하고 있으면 불러오고 

없으면 실행하고 저장하고 뭐 이런 걸 합니다.

그런데 아, 이런 걸 사람이 계속 반복해서 하나씩 하다 보면 여러 가지 단점이 있습니다.

하지만 제가 생각하는 제일 큰 문제는 실수한다는 것 같아요.

반복작업을 하다 보면 당연히 잘 될 거라고 믿었는데 

오타 하나 나고 해서 시간 쓰고 하다 보면 시간이 아깝고 이런 거 왜 하나 싶고 그렇습니다.

그래서 다행히도 흔한 문제에는 답이 있는데요.

아까 많은 분들이 쓰셨다고 했는데 이런 게 있죠.

이걸 쓰면 쉽게 할 수 있는데요. 

일단 큰 장점이 실행의도가 담긴 코드가 있죠.

그래서 캐시를 하는 게 코드의 실행의도를 전혀 해치지 않고요.

그리고 캐시를 하는 코드는 함수로 잘 감싸여져 있기 때문에 

언제든지 재사용할 수 있고 분리가 될 수 있습니다.

감히 함수에 쓸 수 있는 완벽한 해법이라고 할만 한데요. 

하지만 순수함수에 대해서만 그렇습니다.

프로그래밍의 세계는 부작용으로 가득차있는데요.

이 함수가 다음에도 같은 기능을 할지 아무도 모르잖아요.

같은 일을 하는 함수라는 확신이 있을 때만 이런 캐시를 쓸 수 있습니다.

예를 들면 웹사이트를 만들고 게시판에서 목록을 불러온다고 할 때 

게시판목록을 불러오는 함수를 매일 바뀌게 되죠.

그럴 경우에는 안 되거든요.

그러면 이런 건 답이 없느냐.

다행히 이것도 캐시프로그래밍에서 흔하게 겪는 문제이기 때문에 답이 있습니다. 

보통은 캐시의 수명을 많이 저장을 하는데요.

장고에 캐시베이스레코레이터가 그 중 하나이고요.

이건 특정 HTTP를 요청해보면 일정 기간 캐시해주는 역할을 하고요.

지금 인코더해서 15분 동안 유지를 하겠다는 내용입니다.

정말 좋아보이죠? 다 해결된 것 같아요.

자, 그런데 그 장고 아까 쓰신다고 하신 분들 중에 이거 쓰시는 분들 혹시 계세요?

장고 사용자 분들이 꽤 있으셨는데 아무도 안 씁니다.

왜 그러느냐. 

이거 쓸 때는 좋은데 무효화를 시키기가 되게 힘들어요.

이거 쓰는 분을 어제 만나서 아, 되게 오랜만에 봤다. 

이거 도대체 어떻게 무효화를 시키냐 했더니 

"저희는 서비스가 작기 때문에 통째로 날립니다." 하시는 거예요.

물론 작은 건 그래도 되지만 일반적인 건 아니라는 거죠. 

아, 그러면 장고에서 이거는 삭제할 수가 없느냐. 되거든요.

만일 함수 하나만 삭제 시킨다고 하면 지금 화면에 있는 저런 긴 코드를 쓰면 삭제할 수 있습니다. 

하지만 아, 저렇게 하고 싶지 않죠. 

캐시 한번 편하게 하려다가 코드를 6줄씩 쓰고 있으면 한숨이 나옵니다.

그래서 Ring의 접근은 여기서 시작되는데요.

이렇게 하지 말고 Ring을 쓰면 함수에서 저 부분을 삭제시켜주거든요. 

이런 식으로 캐시 인터페이스의 개선을 이루어내겠다는 게 이 라이브러리의 목표입니다.

그럼 이제 본론으로 들어가봅시다.

방금 보신 딜리트 있죠. 

이게 가장 Ring의 특징적인 부분이고요. 

데이터 컨트롤을 쉽게 만들어줍니다.

그래서 가장 기초적인 Ring함수를 볼 거예요. 

왼쪽에 Ring함수이고 오른쪽이 Iru캐시를 쓴 건데요. 

다 똑같고 데이터만 다르죠.

기본실행에서는 양쪽이 큰 차이가 없고요.

하지만 Ring으로 만들면 이렇게 서브펑션을 가지게 되고요. 

펑션이라는 함수에 점을 찍고 딜리트를 표출할 수 있게 되었죠.

방금 장고에서 보신 것처럼 삭제도 마찬가지로 저렇게 시킬 수 있고요. 

서브펑션을 딜리트로 바꿔놓기만 하면 바로 새 내용을 업데이트할 수 있습니다.

다시 처음으로 돌아가면 사실은 이런 식으로 Ring의 기본단위는 서브펑션으로 조직이 되어 있습니다.

그러면 인터페이스를 왜 이렇게 옮겼느냐. 

바로 스토리지를 위해서이고. 

지금 여러 가지를 했는데 그렇게 하면서 스토리지에 대한 코드를 함수를 한번만 만들어 놓으면 

캐시가 어디에 저장되어 있는지 크게 신경쓰지 않고 그냥 코드만 쭉 보고 짤 수 있다는 게 큰 장점이 됩니다.

그래서 뭐 캐시프로그래밍 할 때 편하게 쓰는 삭제, 아니면 

있는 경우만 가지고 오기, 업데이트 하기, 실행만 하기 등등 여러 가지가 내장되어 있고요.

없는데 필요한 기능이 있으면 추가하는 방법도 있습니다.

그래서 아까 잠깐 보고 넘어갔던 장고로 돌아가면 장고에서도 특별한 기능을 추가해넣은 게 아니라요. 

장고에서 원래 할 수 있는 코드를 실행하는 건데 인터페이스만 사람이 쓰기 좋게 한 거거든요.

이렇게만 해도 상당히 쓸만해졌어요.

하지만 이제 여기서 그치면 좀 섭섭하고요.

흔히 써있는 캐시 스토리지들이 여러 값을 동시에 쓸 수 있는 걸 지원하잖아요.

마찬가지로 Ring에서도 이런 걸 성능을 위해서 똑같이 제공을 하고요.

함수 파라미터를 만들어서 넘기면 값도 똑같이 1, 2를 넣으면 1, 2 이런 식으로 함수로 나오게 됩니다.

물론 그냥 실행할 수도 있고 여러 개 설정할 수도 있고 업데이트도 할 수 있고 다 할 수 있고요.

그래서 이렇게 서브펑션으로 인터페이스를 옮기는 것으로 이런 목표들을 달성하려고 했습니다. 

좀 와닿으실지 모르겠는데... ㅎㅎ

다음으로 중요한 주제는 매쏘드와 디스크립터 지원인데요.

디스크립터를 다뤄보신 분들은 아시겠지만 이게 좀 까다로운 문제거든요.

디스크립터는 함수도 아니고 디스크립터가 가지고 있는 함수는 안에 숨어있어서 꺼내기도 쉽지 않죠.

그래서 예제를 하나 준비했는데요.

유저API라는 클래스가 있다고 가정하고요. 

내용은 중요하지 않아요. 

클래스매쏘드와 매쏘드가 있는 걸 보여드리려고 한 거예요.

그래서 적용한다고 생각해보면 변수들이 문제가 되거든요.

그래서 그냥은 안 돼요. 

하지만 사람들이 저걸 해결하려고 만들어놓은 방법들이 있기는 다 있더라고요.

어떻게 하느냐. 데코레이션을 만들어서 적용한다, 이런 식의 방법을 많이 택하고 있고요.

용도에 맞게 그런 개별적인 해법들을 구해서 잘 쓰면 되고 

다들 제품에는 필요한 만큼 해서 쓰는 것 같습니다.

그래서 방법이 없지는 않아요. 

되기는 됩니다. 만들면 다 되는데 쉬운 방법은 아니에요.

Ring은 어떻게 할 수 있느냐. 

이제 Ring을 쓰면 유형별로 해법을 만들 필요가 없고 

완전히 똑같은 사용법으로 내가 기대하는 것과 똑같은 효과를 얻을 수 있어요.

내부에 감싼 게 아까처럼 프리펑션이든 지금처럼 클래스매쏘드든 

뭐 상관없이 같은 인터페이스를 적용할 수 있습니다.

그래서 어디에 할 수 있느냐.

프리펑션 매쏘드 등등... 다 파이썬이 제공하는 내장된 것들이죠. 

이런 것들은 다 이미 제공이 되고요.

그런 것 말고 파이썬에서 널리 쓰이고 있는 것 중에 하이브리드 매쏘드, 프로퍼티 이런 것들이 있는데요. 

이런 것도 크게 컨벤션을 벗어나지 않는 이상 임의의 디스크립터에 자동으로 대응이 되도록 되어 있습니다.

예를 들면 뭐 하이브리드매쏘드를 테스트를 했었는데 잘 됐었습니다.

네, 그래서 Ring을 주위에 소개할 때 많이 듣는 질문 가운데 하나인데요. 

매쏘드나 디스크립터에서 진짜 파라미터만 받아서 동작을 바꾸려면 귀찮아지는데 어떻게 하느냐.

그래서 이제 따로 만들어놨고요. 

와이어로프라고 하고 그런 문제는 이걸 쓰면 다 해결이 됩니다.

그런데 이거는 캐시랑은 크게 관계가 없는 내용이라서 

뒤에서 잠깐 더 이야기를 하기로 하고 일단은 넘어가도록 하겠습니다.

그래서 지금까지는 매쏘드와 디스크립터 지원에 대해서 살펴봤고요. 

목표는 일관성있는 사용방법과 동작을 제공해서 어려운 건 다 Ring이 해주고 사용자는 캐시만 하자는 겁니다.

다음에 다울 내용은 캐시 키의 일관성인데요.

이게 뭐 원래도 중요한 내용이기는 하지만 Ring에서는 특히 더 중요한데 

같은 의미의 함수인자에 대해서 같은 키를 생성해야 되는 문제가 있거든요.

이게 만료가 있기 때문에 중요한 문제가 되는데요.

예를 들면 이런 함수가 있다고 치면요. 

오른쪽에 보면 두 가지 호출 방법이 적혀있는데요. 

펑션에 키워드로 파라미터를 넘길 수 있고 그냥 값으로 넘길 수가 있잖아요.

그런데 사람이 보기에는 이 두 개의 코드가 같은 건데 코드가 보기에는 다른 거거든요.

그래서 이거를 캐시는 두 번에 나눠서 하게 돼요.

그런데 이 경우에는 성능은 좀 떨어지지만 큰 문제는 안 됩니다. 

왜냐하면 캐시가 일을 보는 건 어차피 한두 번이 아니라 굉장히 많이 호출해야 하잖아요.

결국은 두 군데가 다 캐시가 될 거고 아무 문제가 안 됩니다.

그런데 Ring의 경우는 조금 이야기가 다르거든요.

Ring에서는 역시 마찬가지로 키워드 파라미터를 넘길 수 있고 

값으로 파라미터를 넘길 수 있는데 

이 경우에 다른 키를 생성하게 되면 내가 캐시를 v=1로 만들었는데 잘 안 됐어요. 

그러면 사람이 보기에는 같은데 큰일납니다.

그래서 이런 부분이 있으면 만든 사람이 욕을 많이 먹겠죠.

그래서 Ring은 그렇게 하지 않고 항상 같은 키를 만들어내도록 신경을 쓰고 있고요. 

여러 가지 호출 방식을 예시로 써놨는데 전부 다 같은 키를 만들어내고 있습니다.

아까는 안 보였지만 저게 키를 만드는 함수인데요. 

각 함수가 어떤 키를 생성하는지 궁금하면 저런 식으로 찍어볼 수 있습니다.

물론 매쏘드랑 클래스매쏘드 등등도 다 지원하고요.

여기서도 키를 만들 수 있고, 

이거 만들 때는 사실 두세 번째에서 클래스 매쏘드를 같은 키를 만드는 게 좀 어려운 문제였는데 

많은 고생을 했고 어쨌든 이제는 잘 같은 키를 만들어내고 있습니다.

그래서 이런 키 일관성을 포함해서 캐시 키 정책은 저런 것을 만족하고 있고요. 

하나의 캐시만 존재하는 것을 보장해요. 

그래서 캐시키를 가지고 언제든지 캐시에 접근해서 업데이트하고 삭제하고 할 수 있고요.

방금 보신 것처럼 키를 만드는 함수만 따로 호출할 수 있어요. 

그래서 링을 쓰는 프로젝트와 Ring을 쓰지 않는 프로젝트간에 호환이 쉽고요.

그리고 장고에서 캐시 페이지 이런 것들은 보면 키가 사용자가 쓸 수 없는, 

사용자가 만들어낼 수 없는 키를 만들어내거든요.

그런 캐시 같은 것을 만들지 않고 의미있는 문자를 만들기 때문에 

파이썬이 아닌 다른 프로젝트, 뭐 자바프로젝트 이런 것에 호환시킬 때도 같은 키를 만들어내는 게 쉽습니다.

그래서 Ring을 쓸 수 있는데 그럼 이제 어떤 백앤드에서도 쓸 수 있느냐. 여러 가지가 있는데요.

짧게 설명하면 저런 여섯 가지 백앤드를 지원합니다.

각각은 이제 저기 넣을 수 있는 오른쪽에 있는 열 가지 스토리지를 넣을 수 있습니다.

아마 저중에 한 가지를 쓰시겠죠. 다른 거 쓰는 분들은 아직 보지 못했습니다.

그래서 회색처리된 부분만 빼고 다 지원이 됩니다.

그러면 다섯 가지 스토리지만 제공을 하느냐. 

그렇지 않고요. 새로운 백엔드를 추가할 수 있습니다. 

추가하려면 어떻게 해야 되느냐. 코드를 30줄 정도 짜면 금방 추가가 되고요. 

이게 예제로 만든 게 아니라 실제 코드를 가지고 온 거고요. 

모든 백엔드가 이런 식으로 추가가 되어 있습니다.

그래서 마지막으로 제일 중요한 점 중의 하나는 이렇게 만들어놓고 원래 한동안 썼었는데요. 

쓰다 보니까 미묘하게 불편한 점들이 있었어요.

그래서 이 미묘한 불편함들을 해결을 해야겠다고 하다 보니까 

Ring에서 제공하는 거의 모든 제공들을 모듈화를 해서 각각 커스터마이징 가능하게 만들게 되었고요.

예를 들면 처음에 키에 대해서 이야기할 건데 Ring이 생각하는 키를 아까 보여드렸는데요.

모듈이 나오고 프레스가 나오고 함수 이름이 나오고 파라미터가 나오고 하잖아요.

하지만 이 키 쓰고 싶지 않을 수 있잖아요. 

원래 쓰고 있는 키가 있을 수도 있고 다른 걸 쓰고 싶을 수도 있죠.

이를 테면 이제 아티클 함수가 있을 때 이것이 기본적으로 생성해내는 키는 오른쪽과 같이 하는데요.

함수인자에 해당하는 부분은 좋다. 

하지만 프리픽스만 바꿔넘기면 좋겠다. 

하면 처음에 이렇게 하면 바꿔서 나옵니다.

이런 사용 예가 있고요.

다른 방법으로는 아예 키를 다 갈고 싶을 수도 있죠. 

마음에 안 들 수도 있잖아요.

그러면 아티클 함수에 있는 서브펑션 중에 Ring.key라고 있고요. 

이걸 쓰면 완전히 키를 바꿔서 넣을 수 있습니다.

이 두 가지 방법을 쓰면 기존에 사용하던 

코드랑 캐시키에 호환성을 맞추거나 원하는 키를 쉽게 사용할 수 있습니다.

다음으로는 데이터 인코딩에 관한 것인데요.

이제 내 데이터는 복잡하다. 

복잡한 데이터는 대체 어떻게 저장이 되느냐.

기본적으로는 함수에 이렇게 하려고 합니다. 

그런데 지금의 예제는 둘 다 위아래 스토리지가 큰 상관이 없어요.

그런데 우리가 많이 쓰는 스토리지들을 쓰면 얘네는 사실 바이너리 데이터만 넣고 뺄 수 있잖아요.

항상 그렇게 되면 좋은데 그럴 수는 없잖아요. 

파이썬 코드에서도 바이너리 왔다 갔다하는 건 사용하려면 

내가 손으로 매번 그걸 풀었다 묶었다 하려면 많이 줄어들겠죠.

그래서 그렇게 하지 않고 코더라는 걸 지정해서 넣을 수 있고요.

위랑 아래의 차이는 코더를 바꿔서 넣은 건데 내부에 json으로 저장이 되거든요.

이것의 차이는 실제로 스토리지로 쓴 딕트를 열어보면 차이가 보이게 되는데요.

데코레이터 넘긴 딕셔너리를 안에 내용을 열어서 본 거고요.

위에서는 코더를 지정하지 않았으니까 그대로 들어가 있고요. 

아래에서는 코더를 지정했기 때문에 바이너리가 들어가 있게 됩니다.

그래서 위에 있는 형식은 딕트를 스토리지로 쓸 때 쓸 수 있는 방법이지만 

아래처럼 넣으면 저렇게 저장할 수가 있습니다.

그래서 json이 있는 건 좋다. 그런데 다른 걸 쓰고 싶다. 그러면 어떻게 하느냐.

기본적으로 json과 pickle이 내장되어 있고요. 

제가 상상력이 모자란지 몰라도 일반적으로 뭐가 필요한지 몰라서 그러는데 쉬운 인코더를 등록하는 것도 쉽습니다.

먼저 함수별로 인코더와 디코더 함수를 따로따로 지정하는 방법이 있고요. 

아까 앞에서 한 함수인데 코더를 지정하는 대신에 인코더와 디코드를 하나씩 하게 되면 

결과는 아까랑 똑같이 바이너리가 나오는 것을 확인할 수 있고요.

그러면 함수별로 쓰는 게 아니라 나는 자주 쓸 거다. 

자주 쓰는 경우는 어떻게 해야 되느냐.

그러면 뭐 새로운 코드를 이름으로 등록하면 그 이름으로 쓸 수 있습니다.

그래서 Json과 pickle 코드는 저런 식으로 쓸 수 있고요. 

저게 실제로 거의 같은 코드입니다.

그래서 임의의 인코더를 추가하기 좋기 때문에 인코더만 잘 만들어놓으면 쓸 수가 있고요.

저의 경우에는 커스텀코더를 대체 언제 만들어서 썼느냐.

작년에 파이썬으로 돌아가는 내부서비스가 있어서 그걸 썼거든요. 

여러 가지 문제들을 캐시를 해야 되는데 여러 가지 객체의 덤프데이터만 가지고 파일로 할 수가 있었습니다.

그래서 캐시로 할 때는 그냥 로우데이터를 쓰고 불러올 때는 

내부데이터를 까서 필요한 것으로 변화를 시켜주는 것으로 만들어서 썼습니다.

그래서 아, 이런 부분부분을 잘 바꿀 수 있는 걸 알겠다.

그런데 이런 거 알고 캐시 정책을 통째로 바꾸고 싶다.

아니면 뭐 새 매쏘드를 추가해서 쓰고 싶다. 

그러면 어떻게 해야 되느냐.

그럴 때는 이제 유저 인터페이스라는 걸 바꿔서 넣을 수 있고요. 

이건 거의 만능 도구인데 Ring에서는 거의 80%는 이걸 바꾸면 다 해결이 됩니다.

그러다 보니까 여기서 화면으로 설명하기는 좀 어려운 점이 있어서 넘어가겠습니다.

다음으로 로우레벨 인터페이스를 소개하려고 하는데요. 

만약에 Ring에 필요한데 없는 기능이 있다. 

그러면 유저인터페이스 확장을 해야 되냐.

Ring으로 뭐든 만들 수 있을까요? 

제 생각에는 그렇지 않습니다. 

그리고 만약에 설사 Ring이 아주 잘 발전을 해서 뭐든 만들 수 있는 인터페이스를 가지고 있다고 하더라도 

내가 매번 기능을 확장해서 써야 한다고 하면 불편해서 쓸 수가 없죠.

대신에 Ring은 내가 필요한 기능을 필요한 만큼만 잘라서 쓸 수 있게 제공을 합니다.

오늘 예제로 많이 쓴 아티클 함수가 있다고 하면요.

아티클을 실행해서 바로 값을 받아오는 대신 키만 만들고 저 키를 가지고 데이터를 받아오고 

아티클에서 디코더를 실행해서 값을 디코드하고 세 줄에 걸쳐서 작업을 할 수도 있고요.

이건 사실 뭐 아티클점겟과 같은 코드죠. 

왜 한 줄로 할 수 있는 걸 세 줄로 하느냐.

물론 일부러 번거롭게 할 필요는 없고요.

최적화된, 특화된 작업이 있을 수 있는데 이럴 때 평소에는 Ring 인터페이스를 사용하다가 

필요할 때는 각기 다른 방법으로 할 수 있다는 겁니다.

그래서 로우레벨인터페이스를 제공하는 목적은 

Ring에 사용자의 코드를 묶어두지 않는다는 거고요. 

Ring을 쓰더라도 언제든지 원래 방법으로 돌아갈 수 있다는 겁니다.

그래서 다른 방식과 결합해쓸 수 있기 때문에 두려워할 필요가 없습니다.

마지막으로 Ring에 대한 이야기는 이제 끝났고요. 

Ring을 만들면서 알게 된 파이썬에 대해서 짧게 리뷰하고 마치도록 하겠습니다.

먼저 인스펙트 시그니쳐라는 함수가 있는데요. 

이게 함수의 파라미터 값과 어노테이션을 친화적으로 만들어주는 거고요.

파이썬3.3에 들어갔는데 이전에는 힘들었습니다.

잘 보일지 모르겠는데 맨 위랑 아래를 보시면 저 함수를 시그니쳐를 이용하면 

제가 포지셔널인지 키워드인지 아니면 뭐 키워드 인자인지 이런 걸 다 알 수 있고요.

Ring에서는 일관성있는 키를 만드는 데 쓰고 있습니다. 

이런 게 있는지 모르고 처음에 고생하면서 열심히 짰는데요. 

지금은 다 걷어내고 이걸 쓰고 있습니다.

역시 파이썬3.3에 추가되는 것 중에 퀄네임이라는 게 있는데요. 

이건 모듈 안에서 하나의 클래스나 함수를 가리키는 거의 유일한 이름이고요. 

네임과는 조금 다릅니다.

파이썬2에는 아이엠클래스라는 게 있는데 이건 클래스가 다 생성이 되어야지 정보가 들어가거든요. 

이거랑 다르게 클래스 함수를 찍자마자 나오기 때문에 Ring처럼 데코레이터로 값을 받아오는 경우에는 더 유용하고요.

역시 이것도 키일관성을 유지하는 데 중요한 역할을 하고 있습니다.

좀 웃기지만 프리펑션이랑 매쏘드 구분하기 어려운 문제인데 거기서도 쓰이고 있고요.

다음은 어노테이션 문제가 있었는데 파이썬에서 어노테이션은 많이 쓰이죠.

그런데 당연하게도 인트를 한다고 할 때 

겟은 캐시가 있으면 인트가 나오고 없으면 런이 나오고 하는데 

키를 호출을 하면 키는 항상 문자열이잖아요. 문자열이 나오게 되는데...

서브펑션을 호출했는데 뭐 안 붙어있거나 안 맞거나 하면 되게 불편하거든요.

그래서 링에서는 이걸 다 맞춰서 넣어주고 있습니다.

어노테이션은 저렇게 함수에 어노테이션즈라고 들어가 있습니다.

다음으로는 뭐 아까도 좀 이야기한 피클. 피클은 다들 아시죠? 피클은 넘어가고. 

쉘브라는 게 있는데 이건 둘 다 오래된 건데요.

쉘브는 모르시는 분들이 좀 있더라고요. 쉘브는 피클을 쓰는 DB 같은 거고요.

피클 자체가 보안 등의 문제가 있기 때문에 제약사항이 좀 있지만 제약사항 안에서는 아주 유용한 도구입니다.

그래서 매쏘드와 디스크립터. 와이어로프를 쓰면 된다고 했는데요. 

이 컨셉은 클래스에 있는 컨셉을 써넣는 각각 하나하나의 이름을 갖고 있잖아요.

예를 들어서 A라는 클래스에 F라는 함수가 있으면 

이 함수 자체는 하나지만 각 함수가 호출될 때는 서로 다른 것에 의해서 호출되잖아요.

그래서 함수 시그니쳐에 대응하는 것과 호출에 대응하는 것을 분리시키자고 해서 분리시킨 거고 

각각 나누어서 대응을 시켜서 우리가 원하는 모든 경우를 다 커버할 수 있다고 하는 것입니다.

커스텀 구현이나 이런 건 덤으로 하는 거고요.

그래서 우리가 디스크립터를 할 때 관심있는 내용들이 저런 것이었는데요. 

함수인가, 매서드인가, 디스크립터인가, 바인드되는 게 뭐냐, 클래스이냐, 객체냐.

이런 것들이 있는데 해결을 하기는 했고요. 

간신히 해결을 했는데 아주 잘 하고 있지는 않고 

원하는 결과 정도만 겨우 얻을 정도로 하고 있습니다.

키 아이디어는 _f라는 작은 함수를 만들어서 오너쉽을 가진 걸 뭘로 하느냐를 보는 거고요.

여러 파이썬 버전에서 호환되는 걸 만드는 게 힘들었는데 

결론부터 이야기하면 버전별로 책정돼서 이것저것 맞추고 있습니다.

그래서 그와중에 별 건 아니고 파이썬2에서는 인스턴스 매쏘드라는 게 나와야 되는데 

pypy에서는 그냥 매쏘드가 나오더라 해서 다음 버전이 나옵니다.

그래서 이건 고쳤는데 Ring개발에 도움이 됐느냐. 아무 관련없는 거였습니다.

네, 마치도록 하고 이제 장고 확장을 짜기 위해서 테스트를 하다 보니까 

뭐 손으로 테스트할 수는 없고 장고앱은 너무 크잖아요.

그래서 이런 걸 테스트코드에 달고 싶지는 않다.

그래서 장고앱을 새로 만들어서 내장을 시켰고요. 

제가 한 건 아니고 뭐 이것저것 만들어놓은 게 있는데 잘 정리해서 

이걸 파이썬2와 호환되게 만들어서 정리를 해두었습니다.
