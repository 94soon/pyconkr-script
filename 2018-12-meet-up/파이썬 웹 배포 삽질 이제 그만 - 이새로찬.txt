그럼 다음 발표자이신 이새로찬 님을 큰 박수로 맞이해 주시기 바랍니다.

-함께: (박수)

-안녕하세요?

-함께: 안녕하세요?

-연말인데 이렇게 열성적으로 파이썬 미니 컨퍼런스에 참여하신 열정에 정말 박수를 보내드리고 싶습니다.

저는 작년 이맘때 똑같은 연말 세미나 때 라이트닝 토크에서 발표를 했는데 올해는 기술적인 주제로 발표를 하고 싶은 욕심이 있어서 세션으로 준비를 했고요.

그리고 항상 제가 한 해를 시작할 때 목표를 정하는데 그 목표 중 하나가 세미나에서 발표하기 인데 항상 제 꿈을 이룰 수 있게 도와주신 파이콘 준비위원회 여러분께 감사의 인사를 먼저 전하겠습니다.

-함께: (박수)

-그래서 사실 주제는 파이썬 웹 배포 삽질 이제 그만이라는 주제발표를 하게 됐어요.

그 이유는... 원래 주제는 뒤에서 나오지만 파이썬 기반 웹 서비스의 구성과 이해였습니다.

첫 주제가 이거였는데 주최 측에서 삽질기를 조금 더 추가해서 내용을 조금 맞게 변경해달라고 했고요.

구색을 맞추기 위해 저는 삽질을 할 테니 여러분들은 꽃길을 걸으세요라는 파이썬 웹서비스를 하기 위한 구성을 살펴볼까 해요.

그럼 진행하도록 하겠습니다.

우선 제 소개를 짧게 하자면 저는 암호화폐 거래소인 코인원에서 거래하고 있고 글로벌거래소에서 글로벌거래를 만들고 있습니다.

그전에는 마이뮤직테이스티, 작년에 발표할 때 여기 다니고 있었는데 작년에 다녔습니다.

한때는 파이썬을 엄청 좋아했지만 지금 하는 일이 있어서 멀어졌어요.

아쉬운 마음이 있고 개발을 취미로 하고 싶은 개발자입니다.

취미로 했다면 파이썬을 썼을 텐데 일이다 보니까 그게 안 되네요.

그래서 우선 시작을 하자면 이런 전제를 두고 시작할게요.

두 도시의 거리를 계산하는 웹서비스를 만든다고 했을 때 개발사의 사고의 흐름대로 진행해보겠습니다.

첫 번째, 이런 API를 만들 거예요.

디스턴스가 있고 커리스트링으로 베이스, 타깃, 도시를 받아서 구글 맵이나 아니면 지오그래피 데이터가 있는 DB에 요청을 해서 데이터를 가져올 거예요.

그리고 카큘레이션을 하겠죠.

서울의 위도경도, 도쿄의 위도경도를 인풋으로 받아서 거리를 계산하는 연산을 처리할 거예요.

그리고 리스폰으로 그 결과를 내려주겠죠.

개발할 당시에 이렇게 개발을 하게

이제 각각의 애플리케이션에서 수행하는 작업들을 조금 더 깊게 살펴볼게요.

그러면 먼저 데이터를 얻기 위해 하는 작업들은 아이오바운드 작업이 됩니다.

그래서 아이오바운드 작업이 일어나고 카큘레이션은 CPU바운드 작업이 일어납니다.

실제 웹 서비스는 단일이 아니라 동시에 멀티 퀘스트가 들어올 수 있겠죠.

그래서 여기서 고려해야 하는 부분은 IO 블로킹이 있을 거고 그리고 아까 잠깐 로깅 세션에서 언급된 글로벌 인터 프리터 락이라는 파이썬의 특성을 어느 정도 이해가 하고요.

그리고 실제 웹서비스를 하기 위해서 멀티 리퀘스트를 어떻게 핸들링해야 할지에 대한 이해가 필요합니다.

그런데 플라스크, 장고를 개발할 때, 비즈니스 로직을 개발할 때 이 부분까지 생각할 필요가 있을까 하는 논문이 있습니다.

그래서 이 웹 애플리케이션이라는 워딩에 볼드체를 했는데 결국에는 플라스크, 장고 웹 애플리케이션은, 비즈니스 로직이나 아니면 웹에서 모두가 고민을 했었던 인증 그리고 ORM, 그리고 탬플릿 엔진 그리고 퍼미션 관련 등등등에 우리가 모두 웹 개발자로 고민을 가졌던 부분들을 라이브러리화 하고 framework화 해서 고민들을 해결한 툴이자 소프트웨어라고 보시면 되겠죠.

그러면 실제로 Flask 런을 해보면 이런 식의 경고가 뜨게 돼요.

이거는 디벨로먼트 서버고 사용하면 안 되고 프로덕트에서는 WSGI라는 서버를 사용하라고 합니다.

그러면 뒤에 WSGI가 뭔지 공부를 해야 할 힌트를 얻을 수 있습니다.

그렇다면 아까 말했듯이 실제 웹 서비스를 하기 위해서 첫 번째로 고려해야 하는 게 애플리케이션단에서 그런 문제들을 고민하지 않기로 했다면 이제 앞단에서 뭔가 웹서비스를 위해서 받아줘야 하는 시스템이 필요하겠죠.

그래서 모두가 알다시피 저런 역할을 웹서버라는 녀석이 하게 됩니다.

그리고 이런 식의 구성이 되겠죠.

웹서버와 애플리케이션이 통신을 해서 아까와 같이 거리 계산을 처리하는 서비스를 제공하게 됩니다.

하지만 파이썬 웹 애플리케이션 자체는 이렇게 통신을 하면 되지만 통신을 할 수가 없어요.

이론적으로는 가능하게 만들 수는 있지만 효율적이지 않고 그전에 CGI이라는 개념이 있는데 그게 파이썬에서 적합하지 않기 때문에 파이썬만의 웹 서비스를 하기 위한 뭔가가 필요하다는 결론에 도달하게 됩니다.

그래서 PEP 333에서는 여기 작게 적어놨는데 웹서버와 웹 애플리케이션 간에 어떤 단순하고 통용되는 인터페이스가 필요하다고 제안을 합니다.

그래서 만들어진 개념이 인터페이스가 WSGI입니다.

웹서버게이트웨이인터페이스인데 피처 CGI라고 적은 거는 파이썬이 이 인터페이스 조상님 같은 거여서 역사를 알고 싶으신 분들은 같이 보시면 될 것 같습니다.

그래서 간단히 정리를 하자면 파이썬 웹 애플리케이션이 있을 거고 웹 서버가 있을 거고 서로를 커뮤니케이션하기 위한 인터페이스를 정의했었죠.

WSGI는 인터페이스고 실제 구현하는 서버가 우리에게 필요하게 됩니다.

이 서버는 웹 서버와 애플리케이션을 이어주겠죠.

그래서 WSGI, 위스키라고 부르더라고요. 통용되는지 모르겠는데 저희 개발팀의 외국인분은 위스키라고 부르더라고요.

그래서 저도 간단하게 여기서 길기 때문에 위스키라고 부르겠습니다. 위스키 서버에 대해서 알아보자면 위스키 서버 구현체들은 되게 많이 나와 있어요. 모드 파이썬, 이름이 괴랄한 UWSGI, 구니콘이 있는데 여기서 삽질하면서 얻었던 정보를 공유하고 싶습니다.

UWSGI는 특징을 간단히 살펴보면 C로 짜져 있고요.

다이렉트리 서포트 엔진X에서 컴피규레이션을 직접적으로 제공하면서 친화적으로 제공하고 있고요.

그리고 C로 짜져있기 때문에 퍼포먼스적인 측면이나 메모리 사용량이 낮고 구니콘은 파이썬으로 되어 있고 다양한 타입을 지원할 수 있게 됩니다. 워커타입을

그리고 다큐멘션이 잘 되어 있어요.

공식적으로 조사한 게였고 제가 사용하다 보니까 얻은 거는 이게 사용하다 보면 C베이스기 때문에 디버깅이 쉽지 않아요.

그리고 C 에러를 보는 순간 로그에 C 에러가 뜨는데 이 순간마다 패닉이 오긴 해요.

그리고 또 하나는 여기 안 적혀 있는데 컴피규레이션이 생각보다 복잡해서 이것을 잘못했을 때 프로덕션 환경에서 어떤 장애를 발생시키는 원인이 되기도 합니다.

저도 실제로 스레드락이라는 옵션을 잘못 만져서 다운을 시켰던 경험도 있고요.

그리고 구니콘이라는 거는 친절한 문서, 이게 엄청나게 개발을 할 때는 실제 프로덕션 환경에서 큰 영향을 미치는데요.

친절한 문서이고 디버깅이 편합니다.

파이썬 자체로 사용되어 있기 때문에 파이참 자체에서 디버깅을 스택 별로 찾아가면서 확인할 수 있어서 문제 대응에 편리하고요.

뒤에서 몇 가지 더 말씀드릴 거고 잠깐 문서를 보여드리면 이게 구니콘의 공식 다큐멘테이션이고 이게 UWSGI의 공식 다큐멘테이션입니다.

까는 건 아니고 보이는 게 이래요.

그리고 가장 기술 선택에서 하나의 중요한 포인트죠.

누가 쓰고 있는지?

이거는 구니콘이라는 UWSGI 서버를 쓰고 있는 회사의 기술 블로그에 있는데 구니콘은 매우 쉽다.

실제로 써보면 머치 이지.

간단하게 컴피규레이션을 할 수 있고 그리고 이게 사실 인스타그램 테크블로인데 웹서비스에서 CPU 작업을 생각보다 많이 하는데 자기네가 실제로 써 보니까 CPU 작업에서도 나쁘지 않은 성능을 보여주고 있다고 언급을 해줬습니다.

그래서 저도 구니콘을 당당하게 쓸 수 있게 되었고요.

그러면 제가 구니콘을 선택했고 구니콘에 대해서 좀 더 딥하게 살펴보도록 하겠습니다.

구니콘, 아까 말씀드린 장점 중 하나는 UWSG는 설정 파일로 이니시라는 확장자를 가진, 부트될 때 실행이 되지만 구니콘은 파이썬으로 만들어졌기 때문에 파이썬 파일 자체를 파일로 읽어 올라갈 수 있어요.

이런 식으로 바인드 옵션이나 아니면 워커 개수, 로그 파일을 어디다 떨굴 거고 에러 로그를 어디다 떨굴 건지, 워커 클래스는 싱크, 어싱크한 거를 선택할 건지

이런 식으로 동적으로 컴피규레이션이 가능하기 때문에 저희 회사는 컨테이너 환경에서 모든 거를 배포하고 안녕하는데 동적인 컴피규레이션이 엄청난 장점이 됩니다.

왜냐하면 재배포도 필요없고 바로바로

구니콘이라는 거는 시그텀이라는 프로세스 안에 시그널을 보낼 수 있는 그런 것을 통해서 바로바로 이런 컴피규레이션을 바꿔 줄 수 있어요.

그래서 구니콘을 조금 더 실행 해보면서 차차 메커니즘을 살펴보도록 하겠습니다.

그러면 구니콘은 이런 식으로 컨벤션을 가져요. CLI

메인 파일, 그리고 메인 파일에 있는 Flask object

그리고 워커개수, 이런 식으로 하면 기본적으로 Flask 앱을 얘가 관리하는 위스키 서버로 작동을 하게 되고요.

여기서 조금 짚고 넘어가야 할 부분은 워커 개수를 설정할 수 있어요.

일반적으로는 돌리는 서버의 코어 개수 X2에 1이라고 하는데 이 부분은 정답은 아니고요.

각각 서비스에 맞게 CPU 바운드 작업이 많으면 워커 개수를 늘리거나 아니면 IO 작업이 많으면 워커보다 스레드 개수를 늘리면 각각 서비스의 맞는 설정을 해야 합니다.

그리고 저 같은 경우는 지금 맥북, I7에서 띄우기 때문에 워커를 4개로 설정했고요.

실제로 돌리면 이런 식으로 프로세스 5개가 뜨는 걸 볼 수 있어요.

그런데 이게 저는 분명히 워커 4개를 띄웠는데 프로세스 5개가 뜨잖아요.

이 부분 조금 봐볼게요.

그러면 결국 프로세스를 구니콘 그랩 해서 이렇게 봐보면 22047 프로세스가 있고 나머지 하위 프로세스들이 22047을 디펜던시하게 가져가게 되는데요. 그 이유는 구니콘 자체는 메인 프로세스가 있고 나머지 Flask 프로세스들을 구니콘에서 관리하는 컨테이너 형식으로 구니콘을 작동시키게 됩니다.

제가 좀 말이 빠른가요?

괜찮으신가요?

넵

그래서 보면 메인 프로세스가 있고 하위 프로세스들을 관리한다로 알고 짚고 넘어가고요.

실제로는 이렇게 되겠죠.

구니콘이 메인 프로세스로써 리퀘스트 핸들링이나 로드 밸런싱을 앞단에서 하게 되고 실제 리퀘스트를 Flask 프로세스로 전달하게 됩니다.

그래서 여기서 워커라는 개념들이 나왔잖아요.

그러면 구니콘에서는 워커를 어떻게 설정하고 우리에게 맞게 실제 웹서비스에서 어떤 워커를 선택해야 하는지 한번 살펴보도록 하겠습니다.

워커 타입은 여기 컨벤션을 보시면 이런 식으로...

이거 오타인데요. K입니다. 워커 클래스라고 해서 워커 타입을 설정하시면 이런 식으로 부트될 때 어떤 워커를 선택해서 돌리는지 이렇게 뜨게 됩니다.

컨벤션은 그렇고 실제 워커 타입 두 가지 종류로 살펴볼 건데요.

싱크 워커, 어싱크 워커가 있어요.

싱크 워커는 싱크로노스하게 작동하는 테스크의 장점을 가집니다.

그 이유는 한 번에 동시에 싱글 리퀘스트밖에 처리할 수 없고요.

그렇기 때문에 CPU 바운드 작업에 훨씬 더 적절합니다.

어싱크 워커는 웹 환경, 요즘과 같은 때 IO 작업이 많아요. 데이터를 얻기 위해서 블로킹이 되면 안 된다든지 웹 소킷 같이 비동기적으로 보낼 때 어싱크워커가 큰 장점을 같게 됩니다.

갖게 됩니다.

그래서 장점은 저러니까 사실 실제로 간단히라도 벤치마킹, 테스팅을 통해서 근거를 증명해야 하는데요.

그래서 제가 삽질을 대신해서 돌려봤습니다.

보면 테스팅 툴은 AD 테스팅툴 사용해서 했고요.

그리고 여기서 간단하게 퀀커러시 레벨, 총 리퀘스트 개수, 엔드 포인트 테스트를 해써

해봤습니다.

테스트한 종목들을 살펴 보면 하나는 IO 관련된 작업을 하는 API를 테스트 했고 두 번째는 컴퓨팅 관련 테스트를 했고요.

그리고 마지막으로 위에 두 가지 API 혼용해서 작업하는 것을 테스트했습니다. 디테일한 건 여기 나와 있습니다.

그래서 결과를 살펴 보자면 여기서 싱크로 돌렸고요. 디폴트가 싱크이기 때문에 여기서 디폴트를 사용하면 안 되는 이유가 나오게 됩니다.

디폴트를 싱크로 하기 때문에 워커가 싱크, 두 번째는 지벤트 돌고 있고 그리고 마지막으로 테스트를 해봤을 때 결과가 이렇게 나오게 됩니다.

리퀘스트 세컨즈를 지표로 뽑았는데 딜레이 작업일 때 지벤트가 11개 정도의 리퀘스트를 처리할 수 있었고요.

실제로 싱크는 2.67개밖에 처리하지 못했어요.

다양한 결과이긴 하지만 눈으로 확인을 하는 과정이 중요하다고 생각했습니다.

컴퓨팅 작업은 확실히 싱크 작업이 앞서는데 이거는 간단한 컴퓨팅 영상이기 때문에, 더 헤비한 작업을 할 때는 싱크가 확실히 장점을 가진다는 결과를 도출할 수 있었습니다.

그리고 일반적인 웹서비스가 작은 컴퓨팅 연산, 많은 IO 작업을 진행할 텐데 제가 실제 운영했던 서비스들은요.

그래서 저는 지벤트라는 워커 타입을 선택하게 되었습니다.

이 지벤트는 짚고 넘어가면 멀티 스레딩을 이용해서 비동기적인 워커를 돌립니다.

그래서 정리를 해보자면 또 한번 중간정리를 하면 파이썬 웹 애플리케이션이 있고 WSGI 서버로 구니콘을 선택했고 거기에서는 Flask 애플리케이션, Flask 프로세스가 돌게 됩니다.

그리고 WSGI 서버가 도는 실제 어플리케이션과 통신을 하게 되고 앞단 웹서버가 있을 텐데 이 서버는 WSGI에서 중계를 해 주겠죠.

그리고 웹서버는 마지막으로 살펴볼 건데요.

엔진X를 선택할 거예요.

그 이유는 구니콘 공식 다큐멘테이션에서 보면 문서에서 강력하게 엔진X를 추천한다고 적혀 있습니다.

그 이유는 얘네가 많은 뻘짓을 통해서 구니콘에 적합한 웹 서버를 선택해놨고요.

얘네가 엔진 X를 추천하는 이유는 구니콘 자체가 엔진X에 특화된 기능을 사용하는 WSGI 서버로 만들어졌기 때문입니다.

마지막으로 웹 서버를 살펴보면 쓰는 이유는 명확하죠.

프록시 서버로 커넥션을 관리하고 그리고 스테틱 파일을 서빙하고요.

그리고 일반적인 웹서버 기능들을 처리합니다. 파일 업로드 제한, 커넥션 타임 아웃, 버퍼 기능을 처리할 거고요.

일반적인 거는 간단하게 이렇게 넘어가고 구니콘을 사용하면서 우리가 구니콘과 엔진X 조합을 사용하면서 고민해야 할 부분들은 뻘짓했던 부분을 공유드리자면 엔진X를 기본적으로 스트롱 어드바이스 추천한다고 나와 있고요.

구니콘 워커는, 이 이유는 엔진X 제공 버퍼 기능인데요.

일반적인 클라이언트라면 문제가 없는데 웹 서비스에 가끔 슬로우 클라이언트가 있어요.

엄청나게 병목을 만드는데 그 이유는 리스턴스를 받을 때 패킷을 빠르게 빠르게 받지 못하기 때문에 이제 리스턴스를 주는 서버 쪽에서 얘를 기다려야 하는 문제가 발생해요.

이것을 중간에 엔진X의 버퍼 기능을 이용함으로써 실제 애플리케이션이 블록되는 것을 방지할 수 있습니다.

사실 이런 버퍼 기능은 디도스나 이런 공격을 당했을 때 근본적인 해결 방법은 안 되지만 일반적인 애플리케이션에 다이렉트로 리스턴스를 받는 것보다 안정적으로 서비스를 운영할 수 있게 됩니다.

또 하나는 방금 전 버퍼 기능을 언급했는데 그런데 만약에 어싱크워커를 선택했고 서버에서 웹소켓 스트링을 쏴줘야 하는 기능이 구현되어 있을 때 버퍼 기능을 꺼줘야 하는 이슈가 있었습니다.

그래서 말을 빨리 진행을 했는데 마무리를 하자면, 되게 간단합니다. 마무리는

리퀘스트가 들어오면 앞단에서 웹서버인 엔진X가 리퀘스트를 받아주고 엔진X에서 스테틱 파일이 아니라 로직을 타는 거면 구니콘으로 가서 구니콘이 어떤 워크에 그 작업을 할당해 주고요.

그 워커에서 로직을 처리하고 구니콘으로 반환하고 엔진X로 반환하고 리스턴스를 해 주는 형태가 될 것 같습니다.

발표가 너무 빠르게 마무리된 것 같은데요.

제가 말을 너무 빨리 해가지고...

발표는 여기까지고 들어주셔서 감사합니다.

-함께: (박수)

질문 있으시면 해 주시면 감사하겠습니다.

-마지막에 구니콘에 대해서 버퍼 기능 말하기 전에 파이썬에서 공식적으로 엔진X를 사용한다고 ... 거기에서 약간 흐트러져가지고 제대로 이해를 못했거든요.

그 문서에서 공식적으로 엔진X를 권장한다고 적혀 있었나요.

-네, 그러니까 지금 질문이 파이썬에서 엔진X를 권장하느냐고 질문을 해 주신 게 맞죠.

-네.

- 파이썬에서 한 건 아니고요.

파이썬은 웹 서버에 대한 개념까지 가지 않으니까, 구니콘이라는 WSGI 구현체의 다큐멘테이션을 보면 거기에 나와 있습니다. 엔진X를 강력하게 추천한다고

-어디에 적혀 있다고요.

-공식 다큐멘테이션에 적혀 있습니다.

-구니콘 공식 문서에서요?

-네, 여기 제가 인용을 했는데, 이게 구니콘 공식 다큐멘테이션에 적혀 있는 내용이거든요.

구니콘 닥스에서 발최를 했습니다.

발췌를 했습니다.

그렇습니다.

물론 아파치를 써도 됩니다.

하지만 아파치에서 쓰려면 그 버퍼 기능을 이해하고... 엔진X를 쓰는 게 훨씬 적합하다고 얘네가 그렇게 구현을 했다고 말을 하고 있습니다.

-또 혹시 질문 있으신가요?

-잘 모르는데 잘 아시는 거 같아서 여쭤볼게요.

아까 워커라는 게 있는데 그럼 그 WSGI 구니콘에서 워커가 있을 때 그러면 그 워커들은 어떤 작업을 공유할 수 있나요.

아니면 다 다르게 작업을 해야 하나요.

-공유는 사실 할 수 있지만, 리퀘스트를 처리하는 데서 사실 리퀘스트는 단일 리퀘스트고 하나의 서버에서 처리해도 되는 역할이기 때문에 공유할 수는 있어요.

하지만 공유를 하는 서비스를 만드려면 다른 어떤 통신 수단을 써야겠죠. 아니면 파일을 공유한다든지 아니면 DB를 통해서 한다든지 아니면 프로세스랑 통신을 해야 한다든지

-그리고 아까 워커 수에 대한 레커멘데이션이 CPU기반으로 되어 있잖아요.

-맞아요.

-그러면 서비스 하실 때 레커멘데이션에 대해서 하신 건가요?

아니면 변경해서 쓰신 사례가 있으신가요?

-저거는 사실 공식적으로 그냥 얘네가 일반화시켜 놓은 거기 때문에 서비스마다 사실 작업 특성이 다르잖아요.

그래서 저희 회사 같은 경우는 실제 인프라 팀에서 벤치 마킹을 하고 워커 개수를 맞춰서 사용해요.

그리고 AWS 환경에서 사실 인스턴스마다 코어 개수가 다를 수 있으니까 그 부분을 동적으로 아까와 같이 설정할 수도 있습니다.

-제가 잠깐 어디 나갔다가 조금 중복된 질문일 수도 있는데...

구니콘을 많이 쓰는 걸로 알고 있는데 혹시 그런 와스 계열의 서비스를 구니콘 말고 다른 것도 검토해보시거나 혹시 이런 것도 한번 추천을 할 수 있지 않을까요.

-제가 답변부터 드리자면 저는 이 두 가지만 써봤어요. UWSGI와 구니콘

그런데 UWSGI는 장애를 맞딱뜨리고 컴피규레이션을 잘못함으로 인해서 구니콘으로 갔는데 얘네가 옵션 설정이 엄청 복잡해요.

예를 들면 워커 4개를... 자체적으로 워커를 4개 띄웠다 부하가 생기면 워커 8개를 띄우는 것도 생각을 하는데 제가 구니콘을 선택했던 이유는 제가 핸들링 할 수 없는 컴피규레이션을 지원을 해서 제 능력밖의 영역이라고 생각해서 심플하게 간단하게 서비스를 할 수 있는 구니콘을 택했어요.

아까도 잠깐 언급드렸는데 스레드락 이런 게 OS 레벨 개념까지 컴피규레이션 하다 보니까 제 역량 밖이라 포기를 하고 넘어갔습니다.

-시간 관계상 여기까지 하고 넘어가고요.

뒤에 네트워킹 시간 있으니까 궁금한 점은 발표자님 붙들고 물어보면 말씀드릴겁니다.

-그리고 코인원에서 앞단에서 장고를 쓰거든요.

그래서 채용을 하고 있어서...

그렇습니다.

감사합니다.

-다시 한 번 큰 박수 부탁드립니다.

-함께: (박수)

